<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#2c2c2c">
    <title>Future Notes - Trello</title>
    <link rel="apple-touch-icon" sizes="180x180" href="static/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="static/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="static/favicon-16x16.png">
    <link rel="favicon" type="image/x-icon" href="static/favicon.ico">
    <link rel="manifest" href="static/site.webmanifest">
    <script src="/static/js/loader.js"></script>
    <script src="/static/custom-alert.js"></script>
    <script src="/static/admin.js"></script>
    <script src="/static/js/notifications.js"></script>
    <!-- DO NOT MODIFY this style block (color scheme / project-wide contract) -->
    <style>
        :root {
            --bg-color:  #2c2c2c;
            --hdr-color: #3a3a3a;
            --ctr-color: #1e1e1e;
            --btn-color: #424242;
        }
    </style>

    <script>
        fetch("/user-colors")
            .then(res => {
                if (!res.ok) throw new Error("Could not load colors");
                return res.json();
            })
            .then(cfg => {
                document.documentElement.style.setProperty("--bg-color", cfg.background_color);
                document.documentElement.style.setProperty("--hdr-color", cfg.header_color);
                document.documentElement.style.setProperty("--ctr-color", cfg.contrasting_color);
                document.documentElement.style.setProperty("--btn-color", cfg.button_color);

                window.appConfig = {
                    backgroundColor: cfg.background_color,
                    headerColor: cfg.header_color,
                    contrastingColor: cfg.contrasting_color,
                    buttonColor: cfg.button_color
                };
            })
            .catch(err => console.error(err));
    </script>

    <style>
        :root {
        --bg-color:  #2c2c2c;
        --ctr-color: #1e1e1e;
        --btn-color: #424242;
        }

        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: #e0e0e0;
        }

        header {
            background-color: var(--hdr-color);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            position: relative;
        }

        header h1 {
            margin: 0;
            font-size: 28px;
            font-weight: 600;
            color: #f2f2f2;
        }

        nav {
            display: flex;
            gap: 20px;
        }

        nav a {
            text-decoration: none;
        }

        .nav-link {
            position: relative;
            color: white;
            font-size: 18px;
            padding: 5px 0;
            transition: all 0.3s ease;
        }

        .nav-link::after {
            content: "";
            display: block;
            height: 2px;
            width: 0;
            background-color: transparent;
            transition: width 0.3s ease, background-color 0.3s ease;
        }

        .nav-link:hover::after {
            width: 100%;
            background-color: lightgray;
        }

        .nav-link.active::after {
            width: 100%;
            background-color: white;
        }

        .homepage-link {
            text-decoration: none;
            background-color: var(--ctr-color);
            color: #e0e0e0;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
        }

        header a:hover {
            background-color: #5c5c5c;
        }

        .mobile-sub-header {
            display: none;
            background-color: var(--bg-color);
            padding: 10px 0;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            position: relative;
        }

        .mobile-sub-header a {
            display: block;
            color: white;
            text-decoration: none;
            padding: 10px;
            font-size: 18px;
        }

        .mobile-sub-header a.active::after {
            content: "";
            display: block;
            height: 2px;
            width: 100%;
            background-color: white;
        }

        .mobile-sub-header a:hover::after {
            background-color: lightgray;
        }

        .desktop-nav {
            display: flex;
            gap: 20px;
            margin: 0 auto;
        }

        .toggle-mobile-nav {
            background: none;
            border: none;
            color: #f2f2f2;
            font-size: 24px;
            cursor: pointer;
            display: none;
            margin-right: 10px;
        }

        .mobile-header {
            display: none;
            align-items: center;
        }

        @media (max-width: 600px) {
            .desktop-nav {
                display: none;
            }
            
            .mobile-header {
                display: flex;
            }
            
            .toggle-mobile-nav {
                display: block;
            }
            
            .homepage-link {
                display: none;
            }
            #storage-container {
                margin: 0 0 !important;
                margin-right: 166px !important;
            }
        }

        /* Container for counter + bar */
        #storage-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            width: 200px;  /* adjust to your header size */
            font-family: Arial, sans-serif;
            font-size: 12px;
            margin: 0 10px;
        }

        /* Text counter */
        #storage-counter {
            margin-bottom: 4px;
            font-weight: bold;
            color: #ffffff;
        }

        /* Background of progress bar */
        #storage-bar-bg {
            width: 100%;
            height: 8px;
            background-color: #eee;
            border-radius: 4px;
            overflow: hidden;
        }

        /* Filled portion */
        #storage-bar-fill {
            width: 0%; /* dynamically updated by JS */
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #81c784);
            border-radius: 4px 0 0 4px;
            transition: width 0.3s ease, background 0.3s ease;
        }

        /* Red when almost full */
        #storage-bar-fill.almost-full {
            background: linear-gradient(90deg, #ffb74d , #e53935);
        }

        #storage-modal { position: fixed; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,0.6); z-index:2000; }
        #storage-modal .panel { width: 760px; max-width:96%; background: linear-gradient(90deg,#1b1b1b,#121212); color:white; border-radius:12px; padding:20px; box-shadow: 0 10px 40px rgba(0,0,0,0.6); border: 3px solid #ffcc00; }
        #storage-modal .header { display:flex; align-items:center; gap:12px; }
        #storage-modal .logo-badge { background:#ffcc00; color:#111; padding:8px 12px; border-radius:8px; font-weight:800; }
        #storage-modal .big { font-size:28px; font-weight:800; }
        #storage-modal .advert { margin-top:12px; background: linear-gradient(90deg,#ff7a18,#af002d); padding:12px; border-radius:8px; text-align:center; font-weight:700; }
        #storage-modal .invites { margin-top:16px; display:flex; gap:12px; }
        #storage-modal .invites .left, #storage-modal .invites .right { flex:1; }
        #storage-modal .input-row { display:flex; gap:8px; margin-top:8px; }
        #storage-modal .btn { padding:10px 14px; border-radius:8px; background:#333; color:white; border:none; cursor:pointer; }
        #storage-modal .btn.primary { background: linear-gradient(90deg,#ffcc00,#ff8a00); color:#111; font-weight:700; }
        #storage-modal .pending-list { max-height:220px; overflow:auto; margin-top:8px; border-top:1px solid rgba(255,255,255,0.06); padding-top:8px; }
        .almost-full { background: linear-gradient(90deg,#e74c3c,#c0392b) !important; }
        
        /* Infinite storage rainbow bar */
        .infinite-storage {
            background-image: linear-gradient(
                270deg,
                #ff0000,
                #ff7f00,
                #ffff00,
                #00ff00,
                #0000ff,
                #4b0082,
                #8f00ff
            ) !important;
            background-size: 1400% 1400% !important;
            background-position: 0% 50% !important;
            animation: rainbowSlide 5s linear infinite !important;
        }

        @keyframes rainbowSlide {
            0% {
                background-position: 0% 50% !important;
            }
            50% {
                background-position: 100% 50% !important;
            }
            100% {
                background-position: 0% 50% !important;
            }
        }

        #modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        #modal {
            background-color: var(--ctr-color);
            padding: 20px 30px;
            border-radius: 12px;
            text-align: center;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.6);
        }

        #username, #password {
            width: calc(100% - 24px);
            margin: 10px 0;
            background-color: var(--btn-color);
            border: 1px solid #424242;
            color: #E0E0E0;
            padding: 10px;
            border-radius: 8px;
        }

        input {
            background-color: var(--btn-color);
            color: #e0e0e0;
            border: none;
            border-radius: 8px;
            padding: 10px;
            font-size: 16px;
            margin-bottom: 10px;
            outline: none;
            transition: background-color 0.2s;
        }

        button {
            background-color: var(--btn-color);
            color: #e0e0e0;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        input:focus {
            background-color: #5a5a5a;
        }

        button:hover {
            background-color: #616161;
        }
        .profile-pic {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--hdr-color);
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            background-size: cover;
            background-position: center;
        }
        
        .profile-pic.no-picture {
            background-color: #cc4f4f;
            color: white;
            border-radius: 50%;
        }
        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            opacity: 0;
            animation: fadeIn 0.2s forwards 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        /* Base and layout */
        :root {
            --gap: 12px;
            --radius: 10px;
            --muted-text: rgba(224,224,224,0.75);
            --muted-2: rgba(224,224,224,0.55);
            --accent: #ffcc00;
            --danger-grad: linear-gradient(90deg,#ffb74d,#e53935);
            --success-grad: linear-gradient(90deg,#4caf50,#81c784);
            --glass: rgba(255,255,255,0.02);
            --transition: 180ms cubic-bezier(.2,.9,.2,1);
            --list-bg-color: linear-gradient(180deg,var(--ctr-color), #131313);
        }
    </style>
 
    <!-- MAIN STYLES (You allowed edits below - header and the first small block above remain untouched) -->
    <style>

        /* App layout */
        .app-wrap { display:flex; height: calc(100vh - 100px); gap: var(--gap); }
        .sidebar { width: 240px; background: linear-gradient(180deg,var(--ctr-color), #111); padding: 14px; box-shadow: 2px 0 8px rgba(0,0,0,0.6); overflow:auto; border-right: 1px solid rgba(255,255,255,0.02); }
        .sidebar h3 { margin:0 0 8px 0; font-size:14px; color:#fff; }
        .boards-list { display:flex; flex-direction:column; gap:8px; margin-top:12px; }
        .board-item { padding:8px 10px; border-radius:8px; cursor:pointer; display:flex; justify-content:space-between; align-items:center; gap:8px; transition: background var(--transition), transform var(--transition); }
        .board-item:hover { background: rgba(255,255,255,0.03); transform: translateY(-1px); }
        .board-item.active { background: rgba(255,255,255,0.04); font-weight:700; }

        .small-btn { background: var(--btn-color); border:none; padding:6px 8px; border-radius:6px; cursor:pointer; color:#e0e0e0; font-size:13px; transition: transform var(--transition), background var(--transition); }
        .small-btn:hover { transform: translateY(-1px); opacity:0.95; }

        /* Main area & boards */
        .main { flex:1; display:flex; flex-direction:column; overflow:hidden; min-width:0; }
        .board-header { background: transparent; padding:12px 16px; border-bottom:1px solid rgba(255,255,255,0.03); display:flex; align-items:center; justify-content:space-between; gap:12px; }
        .board-title { font-size:18px; font-weight:800; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:80%; }

        .lists-wrap { padding:12px; display:flex; gap:16px; overflow-x:auto; align-items:flex-start; height:100%; align-content:flex-start; }
        .list { min-width:280px; max-width:340px; background: var(--list-bg-color); padding:12px; border-radius:10px; box-shadow: 0 6px 18px rgba(0,0,0,0.5); display:flex; flex-direction:column; gap:10px; }
        .list h4 { margin:0; font-size:14px; display:flex; justify-content:space-between; align-items:center; gap:6px; }
        .card-list { min-height:40px; display:flex; flex-direction:column; gap:10px; }

        /* Smooth expansion and subtle visual cues for drop areas */
        .card-list {
        transition: min-height 220ms cubic-bezier(0.2, 0.8, 0.2, 1),
                    background-color 180ms ease,
                    box-shadow 180ms ease,
                    transform 120ms ease;
        min-height: 40px; /* base small height when not expanded */
        border-radius: 8px;
        padding: 8px;
        background-clip: padding-box;
        }

        /* When dragging starts, enlarge to available space */
        .card-list--active {
        background-color: rgba(0,0,0,0.03);
        }

        /* Visual indicator of the current drop target */
        .card-list--hover {
        outline: 2px dashed rgba(0,0,0,0.12);
        box-shadow: 0 8px 20px rgba(0,0,0,0.06);
        transform: translateY(-4px);
        }

        /* Animations for optimistic card insertion/removal */
        .card {
        transition: transform 220ms cubic-bezier(.2,.9,.3,1),
                    opacity 200ms ease,
                    max-height 260ms ease,
                    margin 200ms ease,
                    padding 200ms ease;
        overflow: hidden;
        will-change: transform, opacity, max-height;
        }

        /* Initial state when newly inserted */
        .card--enter {
        transform: translateY(-8px) scale(0.995);
        opacity: 0;
        max-height: 0;
        margin-top: 0;
        margin-bottom: 0;
        padding-top: 0;
        padding-bottom: 0;
        }

        /* When enter animation is triggered, remove the enter class asynchronously */
        .card--entered {
        transform: none;
        opacity: 1;
        max-height: 1200px; /* large enough to show full content */
        }

        /* Exit animation before actually removing from DOM */
        .card--exit {
        transform: translateY(-8px) scale(0.995);
        opacity: 0;
        max-height: 0;
        margin-top: 0;
        margin-bottom: 0;
        padding-top: 0;
        padding-bottom: 0;
        }

        /* slightly dim temporary cards until server confirms */
        .card--temp {
            opacity: 0.95;
            filter: saturate(0.98);
        }

        /* ===== Card base (keep other card surface rules you already have) ===== */
        /* Ensure base left padding is small so title has full width by default */
        .card {
        position: relative;
        padding-left: 12px; /* small, not reserving checkbox space */
        transition: transform var(--transition), box-shadow var(--transition);
        /* keep your existing background/padding/border-radius etc. from the file */
        }

        /* Sliding title container (hardware-accelerated transform) */
        .card .card-main {
        transition: transform 160ms cubic-bezier(0.2,0.9,0.2,1);
        transform: translateX(0);
        will-change: transform;
        min-width: 0; /* preserve ellipsis/truncation */
        }

        /* Checkbox button - absolute so it doesn't affect layout */
        .card-complete {
        position: absolute;
        left: 8px;
        top: 12px;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        border: 2px solid rgba(255,255,255,0.12); /* visible on dark bg */
        background: transparent !important;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        opacity: 0;
        transform: translateX(-8px) scale(0.92);
        transition: opacity 160ms ease, transform 160ms cubic-bezier(0.2,0.8,0.2,1),
                    background 180ms ease, border-color 160ms ease;
        z-index: 6;
        pointer-events: auto;
        }

        /* Show hover background only if NOT completed */
        .card:not(.card--completed):hover .card-complete,
        .card:not(.card--completed):focus-within .card-complete {
        opacity: 1;
        transform: translateX(0) scale(1);
        background: rgba(255,255,255,0.02);
        border-color: rgba(255,255,255,0.18);
        }
        .card-complete {
            appearance: none;
            -webkit-appearance: none;
            background: transparent;
            padding: 0;
            margin: 0;
            min-width: 0;
            min-height: 0;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            box-sizing: border-box;
        }


        /* Slide title only if not completed */
        .card:not(.card--completed):hover .card-main,
        .card:not(.card--completed):focus-within .card-main {
        transform: translateX(25px);
        }

        /* Completed cards: always shifted */
        .card--completed .card-main {
        transform: translateX(25px);
        }
        

        .card-complete svg {
        width: 16px;   /* slightly bigger */
        height: 16px;
        opacity: 0;
        transform: scale(0.85);
        transition: opacity 140ms ease, transform 140ms cubic-bezier(0.2,0.8,0.2,1);
        fill: transparent;
        pointer-events: none;
        }

        /* Show check when completed */
        .card--completed .card-complete svg {
        opacity: 1;
        transform: scale(1);
        fill: white;
        }


        /* Completed state: filled green background + white check visible + title remains shifted */
        .card--completed .card-complete {
        background: #82B536 !important;
        border-color: rgba(0,0,0,0.06);
        opacity: 1;
        transform: translateX(0) scale(1);
        }
        .card--completed .card-complete svg {
        opacity: 1;
        transform: scale(1);
        fill: white;           /* show the check as white */
        }

        .card-complete {
        width: 24px;
        height: 24px;
        left: 8px;
        top: 12px;
        }


        /* temp state (pending create) - dim the control */
        .card--temp .card-complete {
        opacity: 0.6;
        pointer-events: none;
        }

        /* accessibility focus ring */
        .card-complete:focus {
        outline: 3px solid rgba(46,204,113,0.18);
        outline-offset: 2px;
        }

        /* Card surface improvements */
        .card { background: linear-gradient(180deg,#0f0f0f,#0a0a0a); padding:10px 12px; border-radius:8px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); cursor:grab; user-select:none; display:flex; justify-content:space-between; align-items:flex-start; gap:12px; transition: transform var(--transition), box-shadow var(--transition); }
        .card:hover { transform: translateY(-4px); box-shadow: 0 12px 30px rgba(0,0,0,0.6); }
        .card .card-main { flex:1; min-width:0; }
        .card .card-title-text { margin:0 0 6px 0; font-weight:700; font-size:14px; color: #f3f3f3; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
        .card .card-desc-text { font-size:13px; color: var(--muted-text); white-space:pre-wrap; max-height:72px; overflow:hidden; text-overflow:ellipsis; }

        .card .card-actions { display:flex; flex-direction:column; gap:8px; margin-left:6px; }
        .card .small-btn { padding:6px 8px; font-size:13px; }

        /* Modal / overlay */
        .modal-overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,0.6); z-index:2000; }
        .modal { width:760px; max-width:96%; background: linear-gradient(90deg,#1b1b1b,#121212); color:white; border-radius:12px; padding:20px; box-shadow: 0 10px 40px rgba(0,0,0,0.6); border: 3px solid var(--accent); }

        /* Form controls unified */
        input, textarea { background-color: var(--btn-color); color: #E0E0E0; border: 1px solid rgba(255,255,255,0.04); padding:10px; border-radius:8px; outline:none; transition: box-shadow var(--transition), border var(--transition); font-size:14px; width:100%; }
        input:focus, textarea:focus { box-shadow: 0 6px 20px rgba(0,0,0,0.5); border-color: rgba(255,255,255,0.08); }

        /* Inline editors for cards (improved) */
        .inline-card-edit { display:flex; flex-direction:column; gap:8px; padding:8px; border-radius:8px; background: linear-gradient(180deg,#101010,#0b0b0b); border: 1px solid rgba(255,255,255,0.03); }
        .inline-card-edit .inline-card-title { font-weight:700; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); background:transparent; color:#fff; }
        .inline-card-edit textarea { min-height:72px; max-height:320px; resize:vertical; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); background:transparent; color:#eaeaea; line-height:1.35; }
        .inline-editor-actions { display:flex; gap:8px; justify-content:flex-end; margin-top:6px; }
        .btn { padding:8px 12px; border-radius:8px; cursor:pointer; border: none; }
        .btn.primary { background: linear-gradient(90deg,var(--accent),#ff8a00); color:#111; font-weight:700; }
        .btn.ghost { background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--muted-text); }

        /* small screens */
        @media (max-width: 900px) {
            .sidebar { display:none; }
            .lists-wrap { padding:12px; gap:10px; }
            .list { min-width:260px; }
        }
        .options-menu-color-swatch {
            transition: transform 0.15s, border 0.15s;
        }
        .options-menu-color-swatch:hover {
            transform: scale(1.1);
        }

    </style>

    <!-- SortableJS CDN (drag & drop) -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
</head>
<body>
<header>
    <div class="mobile-header">
        <button id="toggle-mobile-nav" class="toggle-mobile-nav">â˜°</button>
        <input type="password" style="position: absolute; left: -9999px; opacity: 0;">
    </div>
    
    <a href="/" class="homepage-link"><h1>Future Notes</h1></a>
    <nav class="desktop-nav">
        <a href="/index" class="nav-link">Notes</a>
        <a href="/scheduler-page" class="nav-link">Calendar</a>
        <a href="/todo_page" class="nav-link">Todo</a>
        <a href="/trello_page" class="nav-link active">Trello</a>
    </nav>
    <div id="storage-container" style="margin: 0px 100px;">
        <span id="storage-counter">0 / 0 MB</span>
        <div id="storage-bar-bg">
            <div id="storage-bar-fill"></div>
        </div>
    </div>
    <div id="profile-pic" class="profile-pic no-picture"></div>
</header>
      
<nav id="mobileSubHeader" class="mobile-sub-header">
    <a href="/index" class="nav-link">Notes</a>
    <a href="/scheduler-page" class="nav-link">Calendar</a>
    <a href="/todo_page" class="nav-link">Todo</a>
    <a href="/trello_page" class="nav-link active">Trello</a>
</nav>

<div id="storage-modal" role="dialog" aria-hidden="true" class="modal-overlay">
    <div class="modal panel" role="document">
        <div class="header" style="display:flex;align-items:center;gap:12px;justify-content:space-between;">
        <div style="display:flex;align-items:center;gap:12px;">
            <div class="logo-badge" style="background:#ffcc00;color:#111;padding:8px 12px;border-radius:8px;font-weight:800">FUTURE NOTES</div>
            <div style="flex:1">
                <div class="big" style="font-size:20px;font-weight:800">Your storage â€” make it bigger!</div>
                <div style="opacity:0.8">Store notes, files, memories. Invite friends to grow your quota.</div>
            </div>
        </div>
        <div><button id="storage-modal-close" class="btn ghost">âœ•</button></div>
        </div>

        <div class="advert" style="margin-top:12px;background: linear-gradient(90deg,#ff7a18,#af002d);padding:12px;border-radius:8px;text-align:center;font-weight:700;">
            Invite friends â†’ get <strong>+5MB</strong> per verified signup. Limit: <span id="per-day-limit">3</span>/day.
        </div>

        <div class="invites" style="margin-top:16px;display:flex;gap:12px;">
        <div class="left" style="flex:1">
            <h4>Current storage</h4>
            <div style="display:flex; align-items:center; gap:12px;">
            <div style="flex:1; background:#222; height:18px; border-radius:12px; padding:3px;">
                <div id="storage-bar-fill-modal" style="width:0%; height:100%; border-radius:9px; background:linear-gradient(90deg,#ffd166,#ff8a00);"></div>
            </div>
            <div id="storage-counter-modal" style="color:var(--muted-text)">0 / 0 MB</div>
            </div>

            <div style="margin-top:12px;">
            <h4>Invite someone</h4>
            <div>Remaining invites today: <strong id="remaining-today">3</strong></div>
            <div class="input-row" style="display:flex;gap:8px;margin-top:8px;">
                <input id="invite-email" type="email" placeholder="friend@example.com" style="flex:1; padding:10px; border-radius:8px; border:1px solid #333; background:#0f0f0f; color:white;">
                <button id="send-invite-btn" class="btn primary">Send Invite</button>
            </div>
            <div id="invite-feedback" style="margin-top:8px; color:#f1c40f;"></div>
            </div>
        </div>

        <div class="right" style="width:260px">
            <h4>Pending invites</h4>
            <div class="pending-list" id="pending-invites-list" style="max-height:220px;overflow:auto;margin-top:8px;border-top:1px solid rgba(255,255,255,0.06);padding-top:8px;">
            <div style="opacity:0.6">Loading...</div>
            </div>

            <h4 style="margin-top:12px;">Daily stats</h4>
            <div>Sent today: <strong id="sent-today">0</strong></div>
        </div>
        </div>
    </div>
</div>

<div class="app-wrap">
    <aside class="sidebar">
        <div style="display:flex; align-items:center; justify-content:space-between;">
            <h3>Your Boards</h3>
            <div>
                <button id="create-board-btn" class="small-btn">+ Board</button>
            </div>
        </div>

        <div class="boards-list" id="boards-list">
            <!-- list of boards - intentionally not populated on initial start page load -->
        </div>

        <div style="margin-top:12px">
            <input id="new-board-input" placeholder="+ Add board" style="width:96%; padding:8px; border-radius:6px; background:var(--btn-color); border:1px solid #333; color:#e0e0e0;">
        </div>
    </aside>

    <main class="main">
        <!-- Start page container (shows when no board is open) -->
        <div id="start-page" class="start-page" style="display:block;padding:24px;">
            <h2 style="margin-top:0">All boards</h2>
            <div id="start-grid" class="start-grid" style="display:grid;grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));gap:16px;">
                <!-- populated by loadStartPageBoards() -->
            </div>
        </div>

        <!-- Board area (hidden until a board is opened) -->
        <div id="board-area" style="display:none; flex:1; flex-direction:column;">
            <div class="board-header">
                <div class="board-title" id="board-title">Select a board</div>
                <div>
                    <button id="actions-menu-btn" class="small-btn">â€¢â€¢â€¢</button>
                </div>
            </div>

            <div class="lists-wrap" id="lists-wrap">
                <!-- lists (columns) inserted here -->
            </div>
        </div>

    </main>
</div>

<!-- Modals (kept but not used for create/rename flows) -->
<div class="modal-overlay" id="modal-overlay">
    <div class="modal" id="modal" style="display:none;">
        <h3 id="modal-title">Add</h3>
        <div class="modal-body">
            <input id="modal-input" placeholder="Title">
        </div>
        <div class="actions" style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px;">
            <button id="modal-cancel" class="small-btn">Cancel</button>
            <button id="modal-ok" class="small-btn" style="background:var(--accent); color:#111;">OK</button>
        </div>
    </div>
</div>

<script>
/* Global state */
let currentBoardId = null;
let globalBoardBackgroundUrl = null
let boardsCache = []; // list of boards

document.addEventListener("DOMContentLoaded", async () => {
    // Ensure fetch sends cookies
    if (!window.__fetchPatched) {
        const _f = window.fetch;
        window.fetch = (url, opts = {}) => {
            opts.credentials = 'include';
            return _f(url, opts);
        };
        window.__fetchPatched = true;
    }

    // Ping to check session
    async function validateSession() {
        try {
            const res = await fetch("/test-session", { method: "GET" });
            if (res.status === 200) {
                updateStorageCounter();
                loadUserProfile();
                let currentUserId = (await res.json()).user_id;
                sessionStorage.setItem('current_user_id', currentUserId);
                return true;
            }
            if (res.status === 403) {
                window.location.href = '/login_page?suspended=true';
                return false;
            }
            return false;
        } catch (err) {
            return false;
        }
    }

    // Try auto-login
    async function attemptAutoLogin() {
        try {
            const res = await fetch("/login", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({}),
                credentials: 'include'
            });
            if (res.ok) {
                updateStorageCounter();
                loadUserProfile();
                return true;
            }
            // redirect to login page
            window.location.href = '/login_page?suspend=true';
            return false;
        } catch (err) {
            // redirect
            window.location.href = '/login_page?suspend=true';
            return false;
        }
    }

    const ok = await validateSession();
    if (!ok) {
        await attemptAutoLogin();
    }

    // if URL contains a hash like #board-123 -> load that board immediately
    const hashMatch = location.hash.match(/^#board-(\d+)$/);
    if (hashMatch) {
        // populate sidebar and then open board
        await loadBoards();
        const id = parseInt(hashMatch[1], 10);
        // only select if that board actually exists
        if (boardsCache.some(b => b.id === id)) {
            await selectBoard(id);
        } else {
            // fallback: show start page
            await loadStartPageBoards();
            showStartPage();
        }
    } else {
        // initial start page load: fetch boards and render start page cards
        await loadStartPageBoards();
        showStartPage();
    }

    // respond to hash changes (allow navigation between boards without reload)
    window.addEventListener('hashchange', async () => {
        const m = location.hash.match(/^#board-(\d+)$/);
        if (!m) {
            // show start
            currentBoardId = null;
            document.getElementById('board-title').textContent = 'Select a board';
            document.getElementById('lists-wrap').innerHTML = '';
            showStartPage();
            return;
        }
        const id = parseInt(m[1], 10);
        // ensure sidebar is populated
        if (!boardsCache || boardsCache.length === 0) await loadBoards();
        if (boardsCache.some(b => b.id === id)) {
            await selectBoard(id);
        } else {
            showStartPage();
        }
    });
});

/* Storage and profile */

async function updateStorageCounter() {
    try {
        const res = await fetch('/user/storage', { credentials: 'include' });
        if (!res.ok) throw new Error("Failed to fetch storage info");
        const data = await res.json();

        const barHeader = document.getElementById('storage-bar-fill');

        let usedText, totalText, percentUsed;

        if (data.unlimited) {
            usedText = "âˆž";
            totalText = "Unlimited";
            percentUsed = 100; // fill bar fully for effect
            barHeader.classList.add('infinite-storage');
        } else {
            usedText = (data.used_bytes / 1024 / 1024).toFixed(2);
            totalText = (data.total_bytes / 1024 / 1024).toFixed(2);
            percentUsed = Math.min((data.used_bytes / data.total_bytes) * 100, 100);
            barHeader.classList.remove('infinite-storage');
        }

        document.getElementById('storage-counter').textContent = `${usedText} / ${totalText} MB`;
        document.getElementById('storage-bar-fill').style.width = `${percentUsed}%`;

        if (percentUsed > 90 && !data.unlimited) {
            document.getElementById('storage-bar-fill').style.background = 'linear-gradient(90deg,#ffb74d,#e53935)';
        } else {
            document.getElementById('storage-bar-fill').style.background = 'linear-gradient(90deg,#4caf50,#81c784)';
        }
    } catch (err) {
        console.error(err);
    }
}

document.getElementById('storage-container').style.cursor = 'pointer';
document.getElementById('storage-container').addEventListener('click', openStorageModal);
document.getElementById('storage-modal-close').addEventListener('click', closeStorageModal);
document.getElementById('send-invite-btn').addEventListener('click', sendInvite)

async function openStorageModal(e){
    e && e.preventDefault();
    document.getElementById('storage-modal').style.display = 'flex';
    await refreshModalData();
}

function closeStorageModal(){
    document.getElementById('storage-modal').style.display = 'none';
    document.getElementById('invite-feedback').textContent = '';
}

function adjustColor(hex, amount = 20) {
    let usePound = false;
    if (hex[0] === '#') { hex = hex.slice(1); usePound = true; }
    let num = parseInt(hex, 16);
    let r = (num >> 16) + amount;
    let g = ((num >> 8) & 0x00FF) + amount;
    let b = (num & 0x0000FF) + amount;

    r = Math.min(255, Math.max(0, r));
    g = Math.min(255, Math.max(0, g));
    b = Math.min(255, Math.max(0, b));

    const newHex = (r << 16 | g << 8 | b).toString(16).padStart(6, '0');
    return (usePound ? '#' : '') + newHex;
}

function getContrastYIQ(hexcolor){
    hexcolor = hexcolor.replace('#','');
    const r = parseInt(hexcolor.substr(0,2),16);
    const g = parseInt(hexcolor.substr(2,2),16);
    const b = parseInt(hexcolor.substr(4,2),16);
    const yiq = ((r*299)+(g*587)+(b*114))/1000;
    return (yiq >= 128) ? '#000' : '#fff';
}

function applyListTheme(listEl, listColor) {
    if (!listColor) return;

    listEl.style.background = listColor;
    listEl.style.color = getContrastYIQ(listColor);

    // Select all interactive or visual child elements
    const elements = listEl.querySelectorAll('input, textarea, button, .card');
    const lighterColor = adjustColor(listColor, 30); // lighter background for elements

    elements.forEach(el => {
        // Skip cards that already have their own background
        if (el.classList.contains('card') && el.style.background) {
            return;
        }

        if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.classList.contains('card')) {
            el.style.backgroundColor = lighterColor;
            el.style.color = getContrastYIQ(lighterColor);
            el.style.borderColor = adjustColor(listColor, -20); // optional border tint
        }
        if (el.tagName === 'BUTTON') {
            const btnColor = adjustColor(listColor, -10);
            el.style.backgroundColor = btnColor;
            el.style.color = getContrastYIQ(btnColor);
        }
    });
}

async function refreshModalData() {
    try {
        const res = await fetch('/invites/status', { credentials: 'include' });
        if (!res.ok) throw new Error('Failed to load status');
        const data = await res.json();

        const barModal = document.getElementById('storage-bar-fill-modal');

        let usedText, totalText, percent;

        if (data.total_mb === null || data.storage_message) {
            usedText = "âˆž";
            totalText = "Unlimited";
            percent = 100; // fill bar fully for effect
            barModal.classList.add('infinite-storage');
        } else {
            usedText = data.used_mb.toFixed(2);
            totalText = data.total_mb.toFixed(2);
            percent = Math.min((data.used_mb / Math.max(data.total_mb, 1)) * 100, 100);
            barModal.classList.remove('infinite-storage');
        }

        document.getElementById('storage-counter-modal').textContent = `${usedText} / ${totalText} MB`;
        document.getElementById('storage-bar-fill-modal').style.width = percent + '%';

        if (percent > 90 && !(data.total_mb === null || data.storage_message)) {
            barModal.classList.add('almost-full');
        } else {
            barModal.classList.remove('almost-full');
        }

        document.getElementById('remaining-today').textContent = data.remaining_today;
        document.getElementById('sent-today').textContent = data.sent_today;
        document.getElementById('per-day-limit').textContent = data.per_day_limit;

        const pendingList = document.getElementById('pending-invites-list');
        pendingList.innerHTML = '';
        if (!data.pending_invites || data.pending_invites.length === 0) {
            pendingList.innerHTML = '<div style="opacity:0.6">No pending invites</div>';
        } else {
            for (const p of data.pending_invites) {
                const el = document.createElement('div');
                el.style.padding = '8px';
                el.style.borderBottom = '1px solid rgba(255,255,255,0.03)';
                el.innerHTML = `<div style="font-weight:700">${p.email}</div>
                                <div style="opacity:0.6; font-size:12px">Sent ${new Date(p.created_at).toLocaleString()}</div>
                                <button onclick="cancelInvite('${p.id}')" class="cancel-invite-btn">Cancel</button>`;
                pendingList.appendChild(el);
            }
        }
    } catch (err) {
        console.error(err);
        document.getElementById('invite-feedback').textContent = 'Could not load invite status.';
    }
}


async function sendInvite(){
    const email = document.getElementById('invite-email').value.trim();
    if (!email) {
        document.getElementById('invite-feedback').textContent = 'Enter an email first.';
        return;
    }
    document.getElementById('send-invite-btn').disabled = true;
    document.getElementById('invite-feedback').textContent = 'Sending...';

    try {
        const res = await fetch('/invites/send', {
        method:'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({email}),
        credentials: 'include'
        });
        const j = await res.json();
        if (!res.ok) {
        document.getElementById('invite-feedback').textContent = j.error || 'Failed to send';
        } else {
        document.getElementById('invite-feedback').textContent = 'Invite sent! They must sign up via the link to redeem.';
        document.getElementById('invite-email').value = '';
        // refresh
        await refreshModalData();
        }
    } catch (err) {
        console.error(err);
        document.getElementById('invite-feedback').textContent = 'Network error';
    } finally {
        document.getElementById('send-invite-btn').disabled = false;
    }
}

/* Mobile nav toggle */
document.addEventListener("DOMContentLoaded", function() {
    const toggleButton = document.getElementById("toggle-mobile-nav");
    const mobileNav = document.getElementById("mobileSubHeader");

    if (toggleButton && mobileNav) {
        toggleButton.addEventListener("click", function() {
            if (mobileNav.style.display === "block") {
                mobileNav.style.display = "none";
            } else {
                mobileNav.style.display = "block";
            }
        });
    }
});

document.getElementById("profile-pic").addEventListener("click", () => {
    window.location.href = "/account_page";
});


async function loadUserProfile() {
    try {
        const userInfoResponse = await fetch("/user-info", { credentials: 'include' });
        if (userInfoResponse.ok) {
            const userInfo = await userInfoResponse.json();
            const profilePicElement = document.getElementById("profile-pic");
            
            if (userInfo.profile_picture) {
                const correctedProfilePic = userInfo.profile_picture.replace(/\\/g, "/");
                profilePicElement.style.backgroundImage = `url(${correctedProfilePic})`;
                profilePicElement.classList.remove("no-picture");
                profilePicElement.textContent = "";
            } else {
                profilePicElement.textContent = userInfo.username ? userInfo.username[0].toUpperCase() : 'U';
                profilePicElement.classList.add("no-picture");
            }
        }
    } catch (error) {
        console.error("Error loading user profile:", error);
    }
}

/* API helpers */
async function apiGET(path) {
    const res = await fetch(path, { credentials: 'include' });
    if (!res.ok) throw res;
    return await res.json();
}
async function apiPOST(path, body) {
    const res = await fetch(path, { method:'POST', credentials:'include', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
    return res;
}
async function apiPATCH(path, body) {
    const res = await fetch(path, { method:'PATCH', credentials:'include', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
    return res;
}
async function apiDELETE(path) {
    const res = await fetch(path, { method:'DELETE', credentials:'include' });
    return res;
}

/* START PAGE: fetch boards and render as cards */
async function loadStartPageBoards() {
    try {
        // reuse same API used by sidebar; keep in memory
        boardsCache = await apiGET('/api/boards');
        const grid = document.getElementById('start-grid');
        grid.innerHTML = '';

        if (!boardsCache || boardsCache.length === 0) {
            const empty = document.createElement('div');
            empty.className = 'board-card create-large';
            empty.id = 'start-page-new-board';
            empty.style.display='flex'; empty.style.alignItems='center'; empty.style.justifyContent='center'; empty.style.height='120px';
            empty.innerHTML = `<div style="text-align:center; width:100%"><div style="font-size:36px;">ï¼‹</div><div style="opacity:0.8; margin-top:8px">Create your first board</div></div>`;
            empty.addEventListener('click', () => {
                // open inline new board input (will create board)
                showInlineNewBoard(empty.id);
            });
            grid.appendChild(empty);
            return;
        }

        for (const b of boardsCache) {
            const card = document.createElement('div');
            card.className = 'board-card';
            card.dataset.boardId = b.id;
            card.style.borderRadius = '10px';
            card.style.padding = '12px';
            card.style.background = 'linear-gradient(180deg,#161616,#0f0f0f)';
            card.innerHTML = `<h3 style="margin:0 0 8px 0;font-size:16px">${escapeHtml(b.title)}</h3><p style="margin:0;color:var(--muted-2);font-size:13px">${b.cards_count ? `${b.cards_count} ${b.cards_count === 1 ? 'card' : 'cards'}` : 'No cards yet'}</p>`;
            card.addEventListener('click', async () => {
                // when a board card is clicked, populate the sidebar and open the board
                await loadBoards();
                await selectBoard(b.id);
            });
            grid.appendChild(card);
        }

    } catch (err) {
        console.error('Failed to load start page boards', err);
        const grid = document.getElementById('start-grid');
        grid.innerHTML = '<div style="opacity:0.6">Failed to load boards</div>';
    }
}

function showStartPage() {
    document.getElementById('start-page').style.display = 'block';
    document.getElementById('board-area').style.display = 'none';
}
function hideStartPage() {
    document.getElementById('start-page').style.display = 'none';
    document.getElementById('board-area').style.display = 'flex';
}

/* Load boards for sidebar */
async function loadBoards() {
    try {
        boardsCache = await apiGET('/api/boards');
        const list = document.getElementById('boards-list');
        list.innerHTML = '';
        for (const b of boardsCache) {
            const el = document.createElement('div');
            el.className = 'board-item';
            el.dataset.boardId = b.id;
            el.innerHTML = `<div style="display:flex;gap:8px;align-items:center;max-width:160px;overflow:hidden;"><div class="board-title-text" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${escapeHtml(b.title)}</div></div>
                            <div class="board-actions">
                                <button class="small-btn rename-board" title="Rename">âœŽ</button>
                                <button class="small-btn delete-board" title="Delete">ðŸ—‘</button>
                            </div>`;
            // single click selects
            el.addEventListener('click', (e) => {
                if (e.target.closest('.rename-board') || e.target.closest('.delete-board')) return;
                selectBoard(b.id);
            });
            // double click to inline rename
            el.addEventListener('dblclick', (e) => {
                if (e.target.closest('.rename-board') || e.target.closest('.delete-board')) return;
                inlineRenameBoard(b.id, b.title);
            });
            el.querySelector('.rename-board').addEventListener('click', (ev) => {
                ev.stopPropagation();
                inlineRenameBoard(b.id, b.title);
            });
            el.querySelector('.delete-board').addEventListener('click', async (ev) => {
                ev.stopPropagation();
                if (!confirm('Delete board and all its lists/cards?')) return;
                const res = await apiDELETE(`/api/boards/${b.id}`);
                if (res.ok) {
                    if (b.id === currentBoardId) {
                        window.location.hash = '';
                        currentBoardId = null;
                        document.getElementById('board-title').textContent = 'Select a board';
                        document.getElementById('lists-wrap').innerHTML = '';
                    }
                    await loadBoards();
                    await loadStartPageBoards();
                } else {
                    const j = await res.json();
                    alert(j.error || 'Failed to delete');
                }
            });
            list.appendChild(el);
        }

        // do not auto-select any board here - selection happens only when user clicks a card or loads via hash
        highlightActiveBoard();
    } catch (err) {
        console.error(err);
    }
}

function highlightActiveBoard() {
    document.querySelectorAll('.board-item').forEach(el => {
        el.classList.toggle('active', parseInt(el.dataset.boardId,10) === currentBoardId);
    });
}

/* Inline board create / rename UI */
document.getElementById('create-board-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    const input = document.getElementById('new-board-input');
    input.focus();
    return;
});

/* ---------- Inline Add/Edit for Boards ---------- */

/* Sidebar: Add an input at the bottom of the boards list for new board
   (we already added an input in the markup for better accessibility) */

/* ---------- Inline Editing for Boards ---------- */
async function enableBoardInlineEdit(boardEl, boardId) {
    const titleEl = boardEl.querySelector('div:first-child div');
    const currentTitle = titleEl.textContent;
    const input = document.createElement('input');
    input.value = currentTitle;
    input.className = 'inline-board-input input';
    input.style.width = '100%';
    input.style.padding = '6px';
    input.style.borderRadius = '6px';
    input.style.border = '1px solid rgba(255,255,255,0.04)';
    input.style.backgroundColor = 'var(--btn-color)';
    input.style.color = '#e0e0e0';
    titleEl.replaceWith(input);
    input.focus();

    input.addEventListener('keypress', async (e) => {
        if (e.key === 'Enter') {
            const newTitle = input.value.trim();
            if (!newTitle) return;
            const res = await apiPATCH(`/api/boards/${boardId}`, { title: newTitle });
            if (res.ok) {
                await loadBoards();
            } else {
                const j = await res.json();
                alert(j.error || 'Failed');
            }
        }
    });

    input.addEventListener('blur', async () => {
        await loadBoards();
    });
}

/* Attach double-click edit on boards */
function attachBoardEditHandlers() {
    document.querySelectorAll('.board-item > div:first-child').forEach(div => {
        const boardId = parseInt(div.closest('.board-item').dataset.boardId, 10);
        div.ondblclick = () => enableBoardInlineEdit(div.closest('.board-item'), boardId);
    });
}

// Make sure after loadBoards we reattach the inline edit
const originalLoadBoards = loadBoards;
loadBoards = async function() {
    await originalLoadBoards();
    attachBoardEditHandlers();
};

async function createNewBoard(title) {
    const res = await apiPOST('/api/boards', { title });
    return res;
}

document.getElementById('new-board-input').addEventListener('keydown', async (ev) => {
    if (ev.key === 'Enter') {
        const input = ev.target;
        const title = input.value.trim();
        if (!title) return;
        const res = await createNewBoard(title);
        if (res.ok) {
            input.value = '';
            await loadBoards();
            await loadStartPageBoards();
        } else {
            const j = await res.json();
            alert(j.error || 'Failed to create board');
        }
    }
});

function showInlineNewBoard(wrapperId = 'boards-wrapper') {
    const wrapper = document.getElementById(wrapperId);
    if (!wrapper) return;

    // Prevent multiple inline editors
    if (document.getElementById('inline-new-board-container')) return;

    // Move original children into a fragment (this preserves event listeners and state)
    const originalFragment = document.createDocumentFragment();
    while (wrapper.firstChild) {
        originalFragment.appendChild(wrapper.firstChild);
    }

    // Create container for layout
    const inlineContainer = document.createElement('div');
    inlineContainer.id = 'inline-new-board-container';
    inlineContainer.style.display = 'flex';
    inlineContainer.style.alignItems = 'center';
    inlineContainer.style.gap = '8px';
    inlineContainer.style.flexWrap = 'wrap';

    // Create input
    const input = document.createElement('input');
    input.id = 'inline-new-board-input';
    input.type = 'text';
    input.placeholder = 'Enter board name';

    // Create OK button
    const okButton = document.createElement('button');
    okButton.textContent = 'OK';

    // Create Cancel button
    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Cancel';

    // Append input and buttons to container
    inlineContainer.appendChild(input);
    inlineContainer.appendChild(okButton);
    inlineContainer.appendChild(cancelButton);

    // Append container to wrapper
    wrapper.appendChild(inlineContainer);
    input.focus();

    async function finalizeCreation() {
        const title = input.value.trim();
        if (!title) return;

        const res = await createNewBoard(title);
        if (res.ok) {
            // Clear wrapper and call loader (or re-render as needed)
            wrapper.innerHTML = '';
            // If you want to put original content back after successful creation, append originalFragment.
            // But typically loadBoards() will replace the UI so we just call it.
            await loadBoards();
            await loadStartPageBoards();
        } else {
            const j = await res.json();
            alert(j.error || 'Failed to create board');
        }
    }

    function cancelCreation() {
        wrapper.innerHTML = '';
        loadStartPageBoards();
    }

    // Event listeners
    input.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') {
            ev.preventDefault();
            finalizeCreation();
        } else if (ev.key === 'Escape') {
            ev.preventDefault();
            cancelCreation();
        }
    });

    okButton.addEventListener('click', (e) => { e.preventDefault(); finalizeCreation(); });
    cancelButton.addEventListener('click', (e) => { e.preventDefault(); cancelCreation(); });
}


/* ---------- Inline rename for boards ---------- */
async function inlineRenameBoard(boardId, currentTitle) {
    const boardEl = document.querySelector(`.board-item[data-board-id="${boardId}"]`);
    if (!boardEl) return;
    // avoid creating multiple editors
    if (boardEl.querySelector('.inline-board-edit')) {
        boardEl.querySelector('input.inline-board-input')?.focus();
        return;
    }
    const titleDiv = boardEl.querySelector('.board-title-text');
    const original = titleDiv.textContent;
    titleDiv.style.display = 'none';
    const input = document.createElement('input');
    input.className = 'inline-board-input inline-board-edit input-reset';
    input.value = currentTitle;
    input.style.padding = '6px';
    input.style.borderRadius = '6px';
    input.style.border = '1px solid #333';
    input.style.background = 'var(--btn-color)';
    input.style.color = '#e0e0e0';
    input.style.width = '160px';
    titleDiv.parentElement.prepend(input);
    input.focus();
    input.select();

    input.addEventListener('keydown', async (ev) => {
        if (ev.key === 'Enter') {
            const title = input.value.trim();
            if (!title) return;
            const res = await apiPATCH(`/api/boards/${boardId}`, { title });
            if (res.ok) {
                await loadBoards();
                if (currentBoardId === boardId) document.getElementById('board-title').textContent = title;
            } else {
                const j = await res.json();
                alert(j.error || 'Failed to rename');
            }
        } else if (ev.key === 'Escape') {
            // cancel
            cleanup();
        }
    });

    input.addEventListener('blur', cleanup);

    function cleanup() {
        input.remove();
        titleDiv.style.display = '';
    }
}

/* Select board */
async function selectBoard(boardId) {
    currentBoardId = boardId;
    const board = boardsCache.find(b => b.id === boardId);
    document.getElementById('board-title').textContent = board ? board.title : 'Select a board';
    highlightActiveBoard();
    // update URL hash (doesn't reload page)
    location.hash = `#board-${boardId}`;
    // show board area and hide start page
    hideStartPage();
    window._currentBoardId = boardId; // make globally accessible for inline new list
    // load lists for that board
    initBoardActionsMenu();
    await loadLists(boardId);
}

function renderAddListButton() {
    const container = document.getElementById('lists-wrap');
    if (document.getElementById('add-list-button')) return;

    const btnCol = document.createElement('div');
    btnCol.id = 'add-list-button';
    btnCol.innerHTML = `
        <div class="add-list-btn">
            <span class="plus">ï¼‹</span>
            <span class="text">Add another list</span>
        </div>
    `;
    btnCol.addEventListener('click', (ev) => {
        ev.stopPropagation();
        showInlineNewList();
    });
    container.appendChild(btnCol);

    // Apply styling
    const style = document.createElement('style');
    style.innerHTML = `
        .add-list-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            min-width: 180px;
            background: var(--btn-color, rgba(255,255,255,0.08));
            color: #e0e0e0;
            font-weight: 500;
            font-size: 14px;
            transition: background 0.15s ease;
        }
        .add-list-btn:hover {
            background: rgba(255,255,255,0.16);
        }
        .add-list-btn .plus {
            font-weight: 700;
            font-size: 16px;
            line-height: 1;
        }
    `;
    document.head.appendChild(style);
}

function removeAddListButton() {
    const existing = document.getElementById('add-list-button');
    if (existing) existing.remove();
}

// ---------- Implement removeInlineNewList (used by showInlineNewList) ----------
function removeInlineNewList() {
    const inline = document.getElementById('inline-new-list');
    if (inline) inline.remove();
    // restore the persistent add button
    renderAddListButton();
}

// ---------- Updated showInlineNewList (small tweak: hide the CTA when inline is shown) ----------
function showInlineNewList() {
    const container = document.getElementById('lists-wrap');
    // avoid duplicate
    if (document.getElementById('inline-new-list')) {
        const existingInput = document.getElementById('inline-new-list-input');
        if (existingInput) existingInput.focus();
        return;
    }
    // hide/remove the persistent CTA while inline editor is active
    removeAddListButton();

    const col = document.createElement('div');
    col.id = 'inline-new-list';
    col.className = 'list';
    col.innerHTML = `<h4><span><input id="inline-new-list-input" placeholder="New list title" style="width:100%; padding:8px; border-radius:6px; border:1px solid #333; background:var(--btn-color); color:#e0e0e0;" /></span>
                    <span style="display:flex;gap:6px;">
                    <button class="small-btn" id="inline-new-list-cancel">âœ•</button>
                    </span></h4>
                    <div class="card-list" id="cards-for-inline-new"></div>`;
    // Insert inline editor before the CTA area â€” place at the end for horizontal boards
    container.appendChild(col);

    const input = document.getElementById('inline-new-list-input');
    input.focus();
    input.addEventListener('keydown', async (ev) => {
        if (ev.key === 'Enter') {
            const title = input.value.trim();
            if (!title) return;
            // disable input while posting to avoid duplicates
            input.disabled = true;
            try {
                const res = await apiPOST('/api/lists', { title, board_id: currentBoardId });
                if (res.ok) {
                    await loadLists(currentBoardId);
                } else {
                    const j = await res.json();
                    alert(j.error || 'Failed to create list');
                    removeInlineNewList();
                }
            } catch (err) {
                console.error(err);
                alert('Failed to create list');
                removeInlineNewList();
            } finally {
                input.disabled = false;
            }
        } else if (ev.key === 'Escape') {
            removeInlineNewList();
        }
    });
    document.getElementById('inline-new-list-cancel').addEventListener('click', removeInlineNewList);
    input.addEventListener('blur', () => {
        // short timeout so Enter doesn't trigger immediate removal before submission
        setTimeout(() => {
            if (document.activeElement !== input) removeInlineNewList(); renderAddListButton();
        }, 150);
    });
}

function removeInlineNewList() {
    const el = document.getElementById('inline-new-list');
    if (el) el.remove();
}

// Helpers: temporarily expand all .card-list elements to fill their .list parent
function expandCardLists() {
    document.querySelectorAll('.card-list').forEach(cl => {
        const listWrap = cl.closest('.list');
        if (!listWrap) return;

        // find header and footer controls inside the list to compute remaining height
        const header = listWrap.querySelector('h4');
        // footer is the last div containing the input/add button; choose a more robust selector if you have it
        const footer = listWrap.querySelector('div[style*="margin-top"]');

        const headerH = header ? header.getBoundingClientRect().height : 0;
        const footerH = footer ? footer.getBoundingClientRect().height : 0;

        // available height inside the list for the card-list (add small safety padding)
        const available = Math.max(listWrap.clientHeight - headerH - footerH - 8, 120);

        // Use minHeight with transition so content can still shrink naturally otherwise
        cl.style.minHeight = available + 'px';
        cl.classList.add('card-list--active');
    });
}

function collapseCardLists() {
    document.querySelectorAll('.card-list').forEach(cl => {
        cl.style.minHeight = ''; // remove inline style
        cl.classList.remove('card-list--active', 'card-list--hover');
    });
}

// toggle UI class + ARIA
function setCardCompletedUI(cardEl, completed) {
    if (completed) {
        cardEl.classList.add('card--completed');
    } else {
        cardEl.classList.remove('card--completed');
    }
    const btn = cardEl.querySelector('.card-complete');
    if (btn) {
        btn.setAttribute('aria-pressed', completed ? 'true' : 'false');
        btn.title = completed ? 'Mark as not done' : 'Mark as done';
        btn.setAttribute('aria-label', completed ? 'Mark as not done' : 'Mark as done');
    }
}

function attachCardCompleteHandler(cardEl) {
    const btn = cardEl.querySelector('.card-complete');
    if (!btn) return;

    if (btn._hasCompleteHandler) return;
    btn._hasCompleteHandler = true;

    const allowToggleWhenTemp = false;

    // Track how the user activated the control: pointer vs keyboard
    btn._usedPointer = false;
    btn.addEventListener('pointerdown', () => { btn._usedPointer = true; });
    btn.addEventListener('keydown', (ev) => {
        // mark as keyboard interaction so we DON'T blur after toggling
        btn._usedPointer = false;
        // Allow space/enter to still activate via keydown handler (you had one already)
        if (ev.key === ' ' || ev.key === 'Enter') {
            ev.preventDefault();
            // keep keyboard focus; the click handler will run after this
        }
    });

    const handler = async (ev) => {
        ev.stopPropagation();
        ev.preventDefault();

        if (cardEl.classList.contains('card--temp') && !allowToggleWhenTemp) return;

        const was = cardEl.classList.contains('card--completed');
        const next = !was;

        // optimistic UI toggle
        setCardCompletedUI(cardEl, next);

        const cardId = cardEl.dataset.cardId;
        if (String(cardId).startsWith('temp-')) {
            if (!allowToggleWhenTemp) {
                setCardCompletedUI(cardEl, was);
                return;
            }
        }

        try {
            const res = await apiPATCH(`/api/cards/complete/${encodeURIComponent(cardId)}`, { completed: next });
            if (!res.ok) {
                setCardCompletedUI(cardEl, was);
                try {
                    const j = await res.json();
                    alert(j.error || 'Failed to update card completion');
                } catch (e) {
                    alert('Failed to update card completion');
                }
            } else {
                try {
                    const body = await res.json();
                    if (body && typeof body.completed !== 'undefined') {
                        setCardCompletedUI(cardEl, !!body.completed);
                    }
                } catch (e) { /* ignore if no json */ }
            }
        } catch (err) {
            console.error(err);
            setCardCompletedUI(cardEl, was);
            alert('Network error while updating card status');
        } finally {
            // If this was a pointer interaction (mouse/touch), blur the button so :focus-within no longer applies
            if (btn._usedPointer) {
                // small timeout to let any native focus changes settle
                setTimeout(() => {
                    try { btn.blur(); } catch (e) { /* ignore */ }
                    btn._usedPointer = false;
                }, 40);
            }
        }
    };

    btn.addEventListener('click', handler);

    // Keep keyboard activation working for accessibility (Space/Enter)
    btn.addEventListener('keydown', (ev) => {
        if (ev.key === ' ' || ev.key === 'Enter') {
            ev.preventDefault();
            // user is keyboard-activating; keep focus, but trigger click logic
            // click() will call the handler (and usedPointer is false because of keydown listener)
            btn.click();
        }
    });
}


// Create a DOM node for a card. If isTemp is true, the card will be styled as temporary.
// If background_image_url is provided, it takes precedence over background_color.
function createCardElement({ id, title = '', description = '', isTemp = false, completed = false, background_color = null, background_image_url = null }) {
    const cardEl = document.createElement('div');
    cardEl.className = 'card';

    // Apply background: image takes precedence
    if (background_image_url) {
        cardEl.style.background = `url('${background_image_url}') center/cover no-repeat`;
    } else if (background_color) {
        cardEl.style.background = background_color;
    }

    if (isTemp) cardEl.classList.add('card--temp');
    if (completed) cardEl.classList.add('card--completed');

    cardEl.dataset.cardId = id;

    // control markup: a button (accessible) with an inline SVG checkmark
    const checkHtml = `
      <button class="card-complete" aria-pressed="${completed ? 'true' : 'false'}" aria-label="${completed ? 'Mark as not done' : 'Mark as done'}" title="${completed ? 'Mark as not done' : 'Mark as done'}" tabindex="0">
        <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <path d="M20.285 6.708a1 1 0 0 0-1.414-1.416l-9.08 9.08-4.09-4.09A1 1 0 0 0 4.3 11.3l4.99 4.99a1 1 0 0 0 1.414 0l9.58-9.582z"></path>
        </svg>
      </button>
    `;

    cardEl.innerHTML = `
      ${checkHtml}
      <div class="card-main">
        <div style="font-weight:700" class="card-title-text">${escapeHtml(title)}</div>
        <div class="meta card-desc-text">${escapeHtml(description || '')}</div>
      </div>
      <div style="display:flex;flex-direction:column;gap:6px;">
        <button class="small-btn edit-card" title="Edit">âœŽ</button>
        <button class="small-btn delete-card" title="Delete">ðŸ—‘</button>
      </div>
    `;

    if (isTemp) {
        const editBtn = cardEl.querySelector('.edit-card');
        const delBtn = cardEl.querySelector('.delete-card');
        editBtn.disabled = true;
        delBtn.disabled = true;
        editBtn.title = 'Saving...';
        delBtn.title = 'Saving...';
    } else {
        attachCardActionHandlers(cardEl);
    }

    // attach the completion handler even for temp cards (handler will ignore if pointer events disabled)
    attachCardCompleteHandler(cardEl);

    return cardEl;
}

// Attach edit/delete handlers for a real card element
function attachCardActionHandlers(cardEl) {
    const cardId = parseInt(cardEl.dataset.cardId, 10);
    const editBtn = cardEl.querySelector('.edit-card');
    const delBtn = cardEl.querySelector('.delete-card');

    // avoid adding duplicate handlers
    if (!editBtn._hasHandler) {
        editBtn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            inlineEditCard(cardId, cardEl.querySelector('.card-title-text').textContent, cardEl.querySelector('.card-desc-text').textContent, window._currentBoardId);
        });
        editBtn._hasHandler = true;
    }
    if (!delBtn._hasHandler) {
        delBtn.addEventListener('click', async (ev) => {
            ev.stopPropagation();
            if (!confirm('Delete card?')) return;
            const res = await apiDELETE(`/api/cards/${cardId}`);
            if (res.ok) {
                // remove card from DOM
                cardEl.parentElement && cardEl.parentElement.removeChild(cardEl);
            } else {
                const j = await res.json();
                alert(j.error || 'Failed to delete card');
            }
        });
        delBtn._hasHandler = true;
    }

    // double-click to edit
    if (!cardEl._dblHandler) {
        cardEl.addEventListener('dblclick', (ev) => {
            if (ev.target.closest('.edit-card') || ev.target.closest('.delete-card') || ev.target.closest('.card-complete')) return;
            inlineEditCard(cardId, cardEl.querySelector('.card-title-text').textContent, cardEl.querySelector('.card-desc-text').textContent, window._currentBoardId);
        });
        cardEl._dblHandler = true;
    }
}

// animate insertion: apply enter class then after a tick make it entered
function animateInsert(cardEl) {
    cardEl.classList.add('card--enter');
    // force reflow then remove enter to trigger transition to normal state
    requestAnimationFrame(() => {
        // a small timeout yields a smoother animation in some browsers
        setTimeout(() => {
            cardEl.classList.remove('card--enter');
            cardEl.classList.add('card--entered');
        }, 8);
    });
}

// animate removal: add exit class and remove after transition
function animateRemove(cardEl, cb) {
    // ensure it's not also an enter animation
    cardEl.classList.remove('card--enter', 'card--entered');
    cardEl.classList.add('card--exit');
    const duration = 260; // should match the CSS transition timing
    setTimeout(() => {
        if (cardEl.parentElement) cardEl.parentElement.removeChild(cardEl);
        if (typeof cb === 'function') cb();
    }, duration);
}

// Utility: generate a stable temporary id
function makeTempId() {
    return 'temp-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 8);
}

// ---------- Updated loadLists: single options button with generated menu ----------
async function loadLists(boardId) {
    try {
        // fetch payload; API now returns { board_color: string|null, lists: [...] }
        // but keep compatibility if API returns an array (old shape)
        const payload = await apiGET(`/api/lists?board_id=${boardId}`);
        let lists;
        if (Array.isArray(payload)) {
            // backward compatible: API returned array of lists only
            lists = payload;
        } else if (payload && typeof payload === 'object') {
            lists = payload.lists || [];
            boardColor = payload.board_color || null;
            boardBackgroundUrl = payload.board_background_image_url || null;
        } else {
            lists = [];
        }
        if (boardBackgroundUrl) {
            globalBoardBackgroundUrl = boardBackgroundUrl;
            updateBoardMenuUi();
        } else {
            globalBoardBackgroundUrl = null;
        }

        const boardEl = document.getElementById('lists-wrap');
        const boardTitleEl = document.getElementById('board-title');

        if (boardEl) {
            if (boardBackgroundUrl) {
                // use background-image when there is an image
                boardEl.style.background = `url('${boardBackgroundUrl}') center/cover no-repeat`;
                // color contrast on title: use default (white or black) or leave as-is
                if (boardTitleEl) boardTitleEl.style.color = ''; // default contrast for images
            } else if (boardColor) {
                // just a color background
                boardEl.style.background = boardColor;
            } else {
                // reset to default
                boardEl.style.background = '';
                if (boardTitleEl) boardTitleEl.style.color = '';
            }
        }

        const listsWrap = document.getElementById('lists-wrap');
        // clear outer wrapper but keep structure
        listsWrap.innerHTML = '';

        // create an inner container that will be the only sortable area
        let inner = document.createElement('div');
        inner.id = 'lists-inner';
        // keep display: flex or whatever layout you used previously
        inner.style.display = 'flex';
        inner.style.gap = '12px';
        inner.style.alignItems = 'flex-start';
        listsWrap.appendChild(inner);

        // inject options menu styles (once)
        ensureOptionsMenuStyles();

        // render all the lists in order of their order value
        lists.sort((a, b) => a.order - b.order);

        // maintain single open menu reference so we can close when necessary
        let openMenu = null;
        let openMenuCleanup = null;

        // function to create and show the options menu for a given list
        function showOptionsMenu(listId, listTitle, anchorBtn) {
            // close any open menu first
            if (openMenu) {
                closeOptionsMenu();
            }

            const menu = document.createElement('div');
            menu.className = 'options-menu';
            menu.setAttribute('role', 'menu');
            menu.tabIndex = -1; // allow programmatic focus

            // add a header section with a close button and a title and vissualy separate
            const header = document.createElement('div');
            // style the header with js styling
            header.style.padding = '8px 12px';
            header.style.borderBottom = '1px solid var(--hdr-color)';
            header.style.position = 'relative';
            const headerTitle = document.createElement('div');
            headerTitle.className = 'options-menu-header-title';
            headerTitle.textContent = `List: ${listTitle}`;
            const headerCloseBtn = document.createElement('button');
            headerCloseBtn.className = 'options-menu-header-close';
            headerCloseBtn.type = 'button';
            headerCloseBtn.innerHTML = '&times;';
            // Overwrite some default button styles and position it in the header of the menu
            headerCloseBtn.style.position = 'absolute';
            headerCloseBtn.style.top = '0px';
            headerCloseBtn.style.right = '0px';
            headerCloseBtn.style.margin = '5px';
            headerCloseBtn.style.padding = '5px';
            headerCloseBtn.addEventListener('click', (ev) => {
                ev.stopPropagation();
                closeOptionsMenu();
            });
            header.appendChild(headerTitle);
            header.appendChild(headerCloseBtn);
            menu.appendChild(header);
            //add a divider
            const headerDivider = document.createElement('div');
            headerDivider.className = 'options-menu-header-divider';
            menu.appendChild(headerDivider);

            // --- Menu content ---
            // Copy this list with the same title and cards
            const copyItem = document.createElement('button');
            copyItem.className = 'options-menu-item';
            copyItem.type = 'button';
            copyItem.textContent = 'Copy List';
            copyItem.addEventListener('click', async (ev) => {
                ev.stopPropagation();
                closeOptionsMenu();
                // Immediately proceed to making a copy since the backend already has the title, only provide list id in the url
                const res = await apiPOST(`/api/lists/copy/${listId}`);
                if (res.ok) {
                    await loadLists(boardId);
                } else {
                    const j = await res.json().catch(() => ({}));
                    alert(j.error || 'Failed to copy list');
                }
            });
            // Rename
            const renameItem = document.createElement('button');
            renameItem.className = 'options-menu-item';
            renameItem.type = 'button';
            renameItem.textContent = 'Rename';
            renameItem.addEventListener('click', async (ev) => {
                ev.stopPropagation();
                closeOptionsMenu();
                // call existing inline rename helper
                inlineRenameList(listId, listTitle);
            });

            // Delete
            const deleteItem = document.createElement('button');
            deleteItem.className = 'options-menu-item options-menu-item--danger';
            deleteItem.type = 'button';
            deleteItem.textContent = 'Delete';
            deleteItem.addEventListener('click', async (ev) => {
                ev.stopPropagation();
                if (!confirm('Delete list and its cards?')) {
                    return;
                }
                // show immediate feedback by disabling menu while request in progress
                deleteItem.disabled = true;
                try {
                    const res = await apiDELETE(`/api/lists/${listId}`);
                    if (res.ok) {
                        closeOptionsMenu();
                        await loadLists(boardId);
                    } else {
                        const j = await res.json().catch(() => ({}));
                        alert(j.error || 'Failed to delete list');
                        deleteItem.disabled = false;
                    }
                } catch (err) {
                    console.error(err);
                    alert('Network error while deleting list');
                    deleteItem.disabled = false;
                }
            });

            // Divider
            const hr = document.createElement('div');
            hr.className = 'options-menu-divider';

            // --- Color picker grid ---
            const colorContainer = document.createElement('div');
            colorContainer.className = 'options-menu-color-container';
            colorContainer.style.display = 'flex';
            colorContainer.style.flexWrap = 'wrap';
            colorContainer.style.gap = '6px';
            colorContainer.style.margin = '6px 0';
            colorContainer.style.justifyContent = 'flex-start';

            const colors = [
                '#FF6B6B', // Red
                '#FFAD69', // Orange
                '#FFD93D', // Yellow
                '#6BCB77', // Green
                '#4D96FF', // Blue
                '#845EC2', // Purple
                '#FF70A6', // Pink
                '#00C9A7', // Teal
                '#F9F871', // Light yellow
                null       // Default / no color
            ];

            colors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'options-menu-color-swatch';
                swatch.style.width = '32px';
                swatch.style.height = '32px';
                swatch.style.borderRadius = '8px';
                swatch.style.cursor = 'pointer';
                swatch.style.backgroundColor = color || 'var(--btn-color)'; // show default theme if null
                swatch.style.border = '2px solid transparent';
                swatch.title = color || 'Default';

                swatch.addEventListener('mouseover', () => swatch.style.border = '2px solid #fff');
                swatch.addEventListener('mouseout', () => swatch.style.border = '2px solid transparent');

                swatch.addEventListener('click', async (ev) => {
                    ev.stopPropagation();
                    try {
                        // send null to backend if no color
                        const payloadColor = color === null ? null : color;
                        const res = await apiPATCH(`/api/lists/color/${listId}`, { color: payloadColor });
                        if (!res.ok) {
                            const j = await res.json().catch(() => ({}));
                            alert(j.error || 'Failed to update color');
                            return;
                        }
                        // apply instantly without reload
                        const listEl = document.querySelector(`.list[data-list-id="${listId}"]`);
                        if (color === null) {
                            loadLists(boardId); // reload to reset to default theme
                            closeOptionsMenu();
                        } else {
                            if (listEl) applyListTheme(listEl, payloadColor);
                            closeOptionsMenu();
                        }
                    } catch (err) {
                        console.error(err);
                        alert('Network error while updating color');
                    }
                });

                colorContainer.appendChild(swatch);
            });

            // Cancel / Close button
            const cancelItem = document.createElement('button');
            cancelItem.className = 'options-menu-item';
            cancelItem.type = 'button';
            cancelItem.textContent = 'Close';
            cancelItem.addEventListener('click', (ev) => {
                ev.stopPropagation();
                closeOptionsMenu();
            });

            // assemble
            menu.appendChild(colorContainer);
            menu.appendChild(hr.cloneNode());
            menu.appendChild(copyItem);
            menu.appendChild(renameItem);
            menu.appendChild(deleteItem);
            menu.appendChild(hr);
            menu.appendChild(cancelItem);
            // --- end menu content ---

            document.body.appendChild(menu);

            // Position the menu relative to the anchor button
            positionMenuNear(menu, anchorBtn);

            // focus management
            menu.focus();

            // close on outside click or Escape
            function onDocClick(e) {
                if (!menu.contains(e.target) && e.target !== anchorBtn) {
                    closeOptionsMenu();
                }
            }
            function onKeyDown(e) {
                if (e.key === 'Escape') closeOptionsMenu();
            }
            function onScrollOrResize() {
                // reposition so it stays near anchor
                positionMenuNear(menu, anchorBtn);
            }

            document.addEventListener('click', onDocClick);
            window.addEventListener('resize', onScrollOrResize);
            window.addEventListener('scroll', onScrollOrResize, true);
            document.addEventListener('keydown', onKeyDown);

            openMenu = menu;
            openMenuCleanup = () => {
                document.removeEventListener('click', onDocClick);
                window.removeEventListener('resize', onScrollOrResize);
                window.removeEventListener('scroll', onScrollOrResize, true);
                document.removeEventListener('keydown', onKeyDown);
            };
        }

        function closeOptionsMenu() {
            if (!openMenu) return;
            try { openMenuCleanup && openMenuCleanup(); } catch (e) { /* ignore */ }
            try { openMenu.remove(); } catch (e) { /* ignore */ }
            openMenu = null;
            openMenuCleanup = null;
        }

        // positions an absolutely positioned menu near the anchor button with viewport clipping
        function positionMenuNear(menu, anchorBtn) {
            const rect = anchorBtn.getBoundingClientRect();
            const menuWidth = 260; // fixed suggested width
            const menuHeight = 200; // estimate; adjust after insertion
            menu.style.position = 'absolute';
            menu.style.minWidth = menuWidth + 'px';
            menu.style.zIndex = 10000;

            // default: below and aligned to right edge of anchor
            let left = rect.right - menuWidth;
            let top = rect.bottom + window.scrollY + 6;

            // ensure left not off-screen
            if (left < 8) left = 8;
            // ensure top not off-screen bottom
            if (top + menuHeight > window.scrollY + window.innerHeight) {
                // place above anchor instead
                top = rect.top + window.scrollY - menuHeight - 6;
            }

            menu.style.left = left + 'px';
            menu.style.top = top + 'px';
        }

        // Make lists sortable (horizontal) â€” but only the .list elements are draggable.
        // Destroy prior instance if exists to avoid duplicates.
        if (window.Sortable) {
            if (window.listsSortable && typeof window.listsSortable.destroy === 'function') {
                try { window.listsSortable.destroy(); } catch (e) { /* ignore */ }
            }
            window.listsSortable = Sortable.create(inner, {
                animation: 150,
                handle: '.drag-handle',
                draggable: '.list',     // IMPORTANT: only .list items are draggable
                ghostClass: 'sortable-ghost',
                chosenClass: 'sortable-chosen',
                onEnd: async (evt) => {
                    // when drag ends, update the order of lists in backend using only .list children
                    const listEls = inner.querySelectorAll('.list');
                    for (let i = 0; i < listEls.length; i++) {
                        const listId = parseInt(listEls[i].dataset.listId, 10);
                        // Only patch when order actually changed? (optional optimization)
                        await apiPATCH(`/api/lists/order/${listId}`, { order: i });
                    }
                    // reload lists to reflect any changes
                    await loadLists(boardId);
                }
            });
        }

        for (const l of lists) {
            const col = document.createElement('div');
            col.className = 'list';
            col.style.background = l.color || 'var(--list-bg-color)';
            col.dataset.listId = l.id;
            col.innerHTML = `<h4 class="list-header">
                    <span class="list-title-text drag-handle">
                        ${escapeHtml(l.title)}
                    </span>
                    <button
                        class="small-btn options-btn"
                        title="Options"
                        aria-haspopup="true"
                        aria-expanded="false">
                        â‹¯
                    </button>
                </h4>
                <div class="card-list" id="cards-for-${l.id}"></div>
                <div style="margin-top:8px; display:flex; gap:8px;">
                    <input placeholder="Card title" id="new-card-${l.id}" style="flex:1; padding:8px; border-radius:6px; background:var(--btn-color); border:1px solid #333; color:#e0e0e0;">
                    <button class="small-btn add-card" data-list="${l.id}">Add</button>
                </div>`;
            inner.appendChild(col);

            applyListTheme(col, l.color);

            // attach rename-on-dblclick for list title
            const titleSpan = col.querySelector('.list-title-text');
            titleSpan.addEventListener('dblclick', () => inlineRenameList(l.id, l.title));

            // attach options handler to the newly created options button
            const optionsBtn = col.querySelector('.options-btn');
            optionsBtn.addEventListener('click', (ev) => {
                ev.stopPropagation();
                // toggle menu
                if (openMenu) {
                    closeOptionsMenu();
                    return;
                }
                showOptionsMenu(l.id, l.title, optionsBtn);
            });

            // close menu if user clicks the list area (prevent menu from staying open when interacting with cards)
            col.addEventListener('click', () => {
                // nothing else; clicking list should close open menu if any
                if (openMenu) closeOptionsMenu();
            });

            const listEl = col.querySelector('.card-list');
            for (const c of l.cards) {
                const cardEl = createCardElement({
                    id: c.id,
                    title: c.title,
                    description: c.description || '',
                    isTemp: false,
                    completed: !!c.completed,
                    background_color: c.color,
                    background_image_url: c.background_image_url // new property
                });

                console.log(c.color);

                // Ensure UI reflects server state
                setCardCompletedUI(cardEl, !!c.completed);

                // attach edit/delete handlers (createCardElement attaches complete handler already)
                attachCardActionHandlers(cardEl);

                listEl.appendChild(cardEl);
            }

        }

        // ---------- optimistic add-card handlers (replace existing block) ----------
        inner.querySelectorAll('.add-card').forEach(btn => {
            const listId = btn.dataset.list;
            const inp = document.getElementById(`new-card-${listId}`);

            // helper to perform optimistic insert + async request
            async function optimisticCreateCard(title) {
                // create temp element and append immediately
                const tempId = makeTempId();
                const tempCardEl = createCardElement({ id: tempId, title, description: '', isTemp: true });

                const listContainer = document.getElementById(`cards-for-${listId}`);
                // append to end (consistent with current behavior)
                listContainer.appendChild(tempCardEl);
                animateInsert(tempCardEl);

                // fire-and-forget create request
                try {
                    const res = await apiPOST('/api/cards', { title, list_id: parseInt(listId, 10) });
                    if (!res.ok) {
                        // remove temp with animation and notify
                        animateRemove(tempCardEl, () => {
                            res.json().then(j => {
                                alert(j.error || 'Failed to create card');
                            }).catch(() => {
                                alert('Failed to create card');
                            });
                        });
                        return;
                    }

                    // success: try to get returned card data
                    const body = await res.json();
                    // expected: body.id (numeric) and optionally body.title/body.description
                    if (!body || !body.id) {
                        // server didn't return an id; fallback to full reload to ensure consistency
                        await loadLists(window._currentBoardId);
                        return;
                    }

                    // convert temp element into a real card
                    tempCardEl.dataset.cardId = body.id;
                    tempCardEl.classList.remove('card--temp');

                    // update content if server provided full object (title/description)
                    const titleNode = tempCardEl.querySelector('.card-title-text');
                    const descNode = tempCardEl.querySelector('.card-desc-text');
                    if (body.title) titleNode.textContent = body.title;
                    if (body.description) descNode.textContent = body.description;

                    // enable and attach action handlers
                    const editBtn = tempCardEl.querySelector('.edit-card');
                    const delBtn = tempCardEl.querySelector('.delete-card');
                    if (editBtn) { editBtn.disabled = false; editBtn.title = 'Edit'; }
                    if (delBtn) { delBtn.disabled = false; delBtn.title = 'Delete'; }

                    // attach handlers (use updated dataset)
                    attachCardActionHandlers(tempCardEl);

                    // Optionally: ensure Sortable acknowledges new child; Sortable watches DOM so it's fine.
                } catch (err) {
                    console.error(err);
                    animateRemove(tempCardEl, () => {
                        alert('Network error while creating card');
                    });
                }
            }

            // Enter key behavior
            inp.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter') {
                    ev.preventDefault();
                    const title = inp.value.trim();
                    if (!title) return;
                    btn.disabled = true;
                    // optimistic: clear input immediately for snappy UX
                    inp.value = '';
                    optimisticCreateCard(title).finally(() => {
                        btn.disabled = false;
                    });
                } else if (ev.key === 'Escape') {
                    inp.value = '';
                    inp.blur();
                }
            });

            // Click behavior
            btn.addEventListener('click', () => {
                const title = inp.value.trim();
                if (!title) return;
                btn.disabled = true;
                inp.value = '';
                optimisticCreateCard(title).finally(() => {
                    btn.disabled = false;
                });
            });
        });

       // When creating Sortable instances for each .card-list, use these event handlers.
        // Replace your existing per-list Sortable block with the following:
        document.querySelectorAll('.card-list').forEach(list => {
            // destroy prior instance if stored (defensive)
            if (list._sortableInstance && typeof list._sortableInstance.destroy === 'function') {
                try { list._sortableInstance.destroy(); } catch (e) { /* ignore */ }
            }

            list._sortableInstance = new Sortable(list, {
                group: 'boards',
                animation: 150,
                onStart: function (evt) {
                    // expanding all lists when a drag begins
                    expandCardLists();
                },
                onMove: function (evt, originalEvent) {
                    // highlight the list currently under the dragged item (evt.to)
                    const to = evt.to;
                    document.querySelectorAll('.card-list').forEach(cl => {
                        cl.classList.toggle('card-list--hover', cl === to);
                    });
                    // return true to allow the move; if you need to block, return false conditionally
                    return true;
                },
                onEnd: async function (evt) {
                    // collapse visual state immediately when drag ends
                    collapseCardLists();

                    // handle the change (existing logic kept)
                    const toList = evt.to;
                    const toListEl = toList.closest('.list');
                    const listId = parseInt(toListEl.dataset.listId, 10);
                    const cardIds = Array.from(toList.children).map(c => parseInt(c.dataset.cardId, 10));
                    const movedCardId = parseInt(evt.item.dataset.cardId, 10);
                    try {
                        const res = await apiPOST('/api/cards/move', {
                            card_id: movedCardId,
                            to_list_id: listId,
                            order_in_list: cardIds
                        });
                        if (!res.ok) {
                            const j = await res.json();
                            console.error('Move failed', j);
                            await loadLists(boardId);
                        } else {
                            await loadLists(boardId);
                        }
                    } catch (err) {
                        console.error(err);
                        await loadLists(boardId);
                    }
                },
                // keep your existing events like onAdd/onRemove if you use them separately
            });
        });

        // After rendering lists, ensure the persistent CTA is present and outside the inner sortable area
        if (!document.getElementById('inline-new-list')) {
            renderAddListButton(listsWrap); // pass the outer wrapper so CTA is put outside #lists-inner
        }

    } catch (err) {
        console.error(err);
    }

    // --- helper: inject minimal CSS for the generated options menu ---
    function ensureOptionsMenuStyles() {
        if (document.getElementById('generated-options-menu-styles')) return;
        const css = `
        .options-menu {
            background: #222;
            color: #eee;
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            padding: 8px;
            min-width: 220px;
            max-width: 320px;
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        }
        .list-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .list-title-text.drag-handle {
            flex: 1;
            cursor: grab;
            user-select: none;
        }
        .options-btn {
            touch-action: manipulation;
        }
        .options-menu-item {
            display: block;
            width: 100%;
            text-align: left;
            padding: 8px 10px;
            margin: 4px 0;
            border-radius: 6px;
            background: transparent;
            color: inherit;
            border: none;
            cursor: pointer;
            font-size: 13px;
        }
        .options-menu-item:hover { background: rgba(255,255,255,0.03); }
        .options-menu-item:disabled { opacity: 0.5; cursor: default; }
        .options-menu-item--danger { color: #ff7b7b; }
        .options-menu-divider { height: 1px; background: rgba(255,255,255,0.03); margin: 6px 0; border-radius: 1px; }
        .options-menu-color-container { display:flex; align-items:center; gap:8px; padding:6px 2px; margin:4px 0; }
        .options-menu-color { width:40px; height:28px; border:none; background:transparent; cursor:pointer; }
        .options-menu-color-label { font-size: 12px; opacity:0.9; min-width:48px; }
        .options-menu-item--inline { padding:6px 10px; margin-left:auto; font-size:12px; align-self:center; }
        .options-menu-more { margin:6px 2px; padding:6px 8px; font-size:12px; color: #cfcfcf; }
        `;
        const style = document.createElement('style');
        style.id = 'generated-options-menu-styles';
        style.appendChild(document.createTextNode(css));
        document.head.appendChild(style);
    }
}


/* Inline Rename List */
function inlineRenameList(listId, currentTitle) {
    const listEl = document.querySelector(`.list[data-list-id="${listId}"]`);
    if (!listEl) return;
    const titleSpan = listEl.querySelector('.list-title-text');
    if (!titleSpan) return;
    if (listEl.querySelector('.inline-list-edit')) {
        listEl.querySelector('.inline-list-input')?.focus();
        return;
    }
    titleSpan.style.display = 'none';
    // create input
    const input = document.createElement('input');
    input.className = 'inline-list-input inline-list-edit';
    input.value = currentTitle;
    input.style.padding = '6px';
    input.style.borderRadius = '6px';
    input.style.border = '1px solid #333';
    input.style.width = '160px';

    // append first so we can style
    titleSpan.parentElement.prepend(input);

    // apply the list's theme
    applyListTheme(listEl, listEl.style.background || null);

    // focus/select
    input.focus();


    input.addEventListener('keydown', async (ev) => {
        if (ev.key === 'Enter') {
            const title = input.value.trim();
            if (!title) return;
            const res = await apiPATCH(`/api/lists/${listId}`, { title });
            if (res.ok) {
                await loadLists(currentBoardId);
            } else {
                const j = await res.json();
                alert(j.error || 'Failed to rename list');
            }
        } else if (ev.key === 'Escape') {
            cleanup();
        }
    });
    input.addEventListener('blur', cleanup);
    function cleanup() {
        input.remove();
        titleSpan.style.display = '';
    }
}

/* Improved inline edit card
   - replaces previous single-line editing with a properly autosizing textarea
   - provides explicit Save / Cancel buttons
   - keyboard shortcuts: Enter on title saves, Ctrl+Enter in description saves, Esc cancels
   - lives inside the card element to minimize context switching
*/
function inlineEditCard(cardId, currentTitle, currentDesc, boardId) {
    openCardModal(cardId);
}

(function () {
    // Ensure modal is created once
    let _cardModal = null;
    let _cardModalState = { cardId: null, currentUserId: null };

    // Create modal DOM and return reference
    function ensureCardModal() {
        if (_cardModal) return _cardModal;

        const modal = document.createElement('div');
        modal.id = 'card-modal';
        modal.className = 'card-modal';
        modal.style.display = 'none';
        modal.innerHTML = `
            <div class="card-modal-backdrop" tabindex="-1"></div>
            <section class="card-modal-panel" role="dialog" aria-modal="true" aria-labelledby="card-modal-title">
                <div class="card-modal-inner">
                    <button id="card-modal-cancel" class="btn ghost x-right-top-close-button">X</button>
                    <div class="card-modal-left">
                        <header class="card-modal-header">
                            <input id="card-modal-title" class="card-modal-title" placeholder="Card title">
                            <div class="card-modal-actions" id="card-modal-actions">
                                <!-- Action buttons placeholder -->
                            </div>
                        </header>

                        <!-- Card color swatches inserted between title and description -->
                        <div id="card-modal-color" class="card-modal-color" aria-label="Card color">
                            <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:8px;">
                            <label class="label" style="margin:0;font-size:13px;">Card color</label>
                            <div style="font-size:12px;opacity:0.8;">Pick a color</div>
                            </div>
                            <div id="card-modal-color-swatches" class="swatch-grid"></div>
                        </div>

                        <div class="card-modal-body">
                            <label class="label">Description</label>
                            <textarea id="card-modal-desc" class="card-modal-desc" placeholder="Add a description..."></textarea>
                        </div>

                        <footer class="card-modal-footer">
                            <button id="card-modal-save" class="btn">Save</button>
                        </footer>
                    </div>

                    <aside class="card-modal-right">
                        <h4 class="activity-title">Activity</h4>
                        <div id="card-activity-list" class="activity-list"></div>

                        <div class="add-comment">
                            <textarea id="card-new-comment" placeholder="Write a comment..."></textarea>
                            <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px;">
                                <button id="card-add-comment" class="btn">Comment</button>
                            </div>
                        </div>
                    </aside>
                </div>
            </section>
        `;

        // Minimal styles (scoped)
        const style = document.createElement('style');
        style.textContent = `
        /* Modal backdrop/panel */
        .card-modal { position:fixed; inset:0; z-index:1200; font-family:inherit; }
        .card-modal-backdrop { position:absolute; inset:0; background:rgba(0,0,0,0.45); backdrop-filter: blur(2px); }
        .card-modal-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 1100px;
            height: 50vh;
            max-height: 900px;

            display: flex;
            border-radius: 16px;          /* Rounded corners on the outer modal */
            overflow: hidden;             /* Important: clip inner content to the rounded corners */
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }
        .card-modal-inner { display:flex; width:100%; box-shadow: -20px 0 40px rgba(0,0,0,0.6); height:100%; }
        .x-right-top-close-button {
            position: absolute;
            top: 12px;
            right: 12px;
            background: var(--btn-color);
            color: #e0e0e0;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 14px;
            cursor: pointer;
        }
        .card-modal-left {
            width: 60%;
            background: var(--ctr-color, #0f0f0f);
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow: auto;
            border-top-left-radius: 16px;    /* Rounded top-left corner */
            border-bottom-left-radius: 16px; /* Rounded bottom-left corner */
        }
        .card-modal-right {
            width: 40%;
            background: var(--bg-color, #141a2b);
            color: #e0e0e0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow: auto;
            border-top-right-radius: 16px;   /* Rounded top-right corner */
            border-bottom-right-radius: 16px;/* Rounded bottom-right corner */
        }
        .card-modal-header { display:flex; gap:12px; align-items:center; justify-content:space-between; }
        .card-modal-title { font-size:20px; width:100%; padding:8px; border-radius:6px; border:1px solid #333; background:var(--btn-color); color:#e0e0e0; }
        .card-modal-body { display:flex; flex-direction:column; gap:8px; }
        .card-modal-desc { width:96%; min-height:200px; padding:12px; border-radius:8px; border:1px solid #333; background:var(--btn-color); color:#e0e0e0; resize:vertical; }
        .card-modal-footer { display:flex; justify-content:flex-end; gap:8px; padding-top:8px; }
        .activity-title { margin:0 0 4px 0; font-weight:700; font-size:14px; color:#fff; }
        .activity-list { display:flex; flex-direction:column; gap:10px; }
        .activity-item { padding:10px; border-radius:8px; background: rgba(255,255,255,0.02); font-size:13px; }
        .activity-item .meta { font-size:12px; opacity:0.7; margin-bottom:6px; }
        .activity-item .content { white-space:pre-wrap; }
        .activity-controls { display:flex; gap:6px; margin-top:8px; }
        .add-comment textarea { width:96%; min-height:80px; padding:10px; border-radius:8px; border:1px solid #333; background:var(--btn-color); color:#e0e0e0; resize:vertical; }
        .activity-item .you { font-weight:700; }
        /* Card color swatches - mirrors board menu swatches */
        .card-modal-color { display:flex; flex-direction:column; gap:8px; }
        .card-modal-color .swatch-grid { display:flex; flex-wrap:wrap; gap:8px; }
        .card-modal-color .swatch { width:28px; height:28px; border-radius:6px; cursor:pointer; border:2px solid transparent; box-sizing:border-box; }
        .card-modal-color .swatch:focus, .card-modal-color .swatch:hover { transform: translateY(-2px); border-color: rgba(255,255,255,0.12); outline:none; }
        .card-modal-color .swatch--default { display:flex; align-items:center; justify-content:center; background: repeating-linear-gradient(45deg, #2b2b2b 0 6px, #262626 6px 12px); color: rgba(255,255,255,0.5); font-size:11px; padding:0 6px; }
        .card-modal-color .swatch.selected { border-color: rgba(255,255,255,0.35); box-shadow: 0 3px 8px rgba(0,0,0,0.45); }
        `;

        document.head.appendChild(style);
        document.body.appendChild(modal);

        // Close / cancel handlers
        modal.querySelector('.card-modal-backdrop').addEventListener('click', () => closeCardModal());
        modal.querySelector('#card-modal-cancel').addEventListener('click', () => closeCardModal());
        modal.querySelector('#card-modal-save').addEventListener('click', () => saveCardModal());

        // Add comment
        modal.querySelector('#card-add-comment').addEventListener('click', () => addCommentFromModal());

        // initialize the color swatches UI
        initCardColorSwatches(modal);

        // --- Upload background controls (card-level) ---
        initCardBackgroundUpload(modal);

        function initCardBackgroundUpload(modalEl) {
            const uploadContainer = document.createElement('div');
            uploadContainer.classList.add('bm-section');
            uploadContainer.style.marginTop = '8px';

            // Visual label
            const uploadLabel = document.createElement('div');
            uploadLabel.className = 'options-menu-color-label';
            uploadLabel.textContent = 'Card background image';
            uploadLabel.style.fontSize = '13px';
            uploadLabel.style.opacity = '0.95';
            uploadContainer.appendChild(uploadLabel);

            // file input (hidden) + visible button to trigger it
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*';
            fileInput.style.display = 'none';

            const uploadBtn = document.createElement('button');
            uploadBtn.type = 'button';
            uploadBtn.className = 'options-menu-item options-menu-more';
            uploadBtn.textContent = (_cardModalState.cardBackgroundUrl ? 'Change background image' : 'Upload background image');
            uploadBtn.addEventListener('click', () => fileInput.click());

            const bgControls = document.createElement('div');
            bgControls.style.display = 'flex';
            bgControls.style.alignItems = 'center';
            bgControls.style.gap = '8px';
            bgControls.style.marginTop = '6px';

            const thumb = document.createElement('img');
            thumb.style.width = '64px';
            thumb.style.height = '40px';
            thumb.style.objectFit = 'cover';
            thumb.style.borderRadius = '6px';
            thumb.style.display = 'none'; // shown when image exists

            const deleteBgBtn = document.createElement('button');
            deleteBgBtn.type = 'button';
            deleteBgBtn.className = 'options-menu-item options-menu-item--danger';
            deleteBgBtn.textContent = 'Remove background';
            deleteBgBtn.style.display = 'none';

            uploadContainer.appendChild(fileInput);
            uploadContainer.appendChild(uploadBtn);
            uploadContainer.appendChild(bgControls);
            bgControls.appendChild(thumb);
            bgControls.appendChild(deleteBgBtn);

            // helper: update thumbnail + visibility based on current state
            function renderCardBgState() {
                if (_cardModalState.cardBackgroundUrl) {
                    thumb.src = _cardModalState.cardBackgroundUrl;
                    thumb.style.display = 'block';
                    deleteBgBtn.style.display = 'inline-block';
                    uploadBtn.textContent = 'Change background image';
                } else {
                    thumb.style.display = 'none';
                    deleteBgBtn.style.display = 'none';
                    uploadBtn.textContent = 'Upload background image';
                }
            }

            // helper: apply background (or clear it) to modal and board card immediately
            function applyBackgroundToUI(cardId, backgroundUrl, color) {
                // update modal state
                _cardModalState.cardBackgroundUrl = backgroundUrl || null;
                if (typeof color !== 'undefined') _cardModalState.cardColor = color || null;

                // update left panel
                const left = modalEl.querySelector('.card-modal-left');
                if (left) {
                    if (_cardModalState.cardBackgroundUrl) {
                        left.style.background = `url('${_cardModalState.cardBackgroundUrl}') center/cover no-repeat`;
                    } else if (_cardModalState.cardColor) {
                        left.style.background = _cardModalState.cardColor;
                    } else {
                        left.style.background = '';
                    }
                }

                // update board card element if present
                const cardEl = document.querySelector(`.card[data-card-id="${cardId}"]`);
                if (cardEl) {
                    if (_cardModalState.cardBackgroundUrl) {
                        cardEl.style.background = `url('${_cardModalState.cardBackgroundUrl}') center/cover no-repeat`;
                    } else if (_cardModalState.cardColor) {
                        cardEl.style.background = _cardModalState.cardColor;
                    } else {
                        cardEl.style.background = '';
                    }
                }

                // refresh upload UI (thumbnail + buttons)
                if (modalEl && typeof modalEl._renderCardBgState === 'function') {
                    modalEl._renderCardBgState();
                }
            }


            fileInput.addEventListener('change', async (ev) => {
                if (!fileInput.files || fileInput.files.length === 0) return;
                const f = fileInput.files[0];
                uploadBtn.disabled = true;
                deleteBgBtn.disabled = true;
                uploadBtn.textContent = 'Uploadingâ€¦';

                const cardId = _cardModalState.cardId;
                try {
                    // Step 1: POST to generic /uploads (multipart)
                    const form = new FormData();
                    form.append('file', f);
                    const res1 = await fetch('/uploads', {
                        method: 'POST',
                        body: form
                    });

                    if (!res1.ok) {
                        const err = await res1.json().catch(() => ({}));
                        alert(err.error || 'Upload failed');
                        return;
                    }
                    const body = await res1.json();
                    const uploadId = body.upload_id || body.id || body.id_upload;

                    if (!uploadId) {
                        // try to find a direct url if server returns it
                        const possibleUrl = body.url || body.file_url || body.upload_url;
                        if (possibleUrl) {
                            // attach step may not be required by API shape; continue with url
                            applyBackgroundToUI(cardId, possibleUrl, _cardModalState.cardColor);
                            return;
                        }
                        alert('Upload returned unexpected response');
                        return;
                    }

                    // Step 2: attach that upload to the card
                    const res2 = await fetch(`/api/cards/${cardId}/background_uploads`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ upload_id: uploadId })
                    });

                    if (!res2.ok) {
                        const err = await res2.json().catch(() => ({}));
                        alert(err.error || 'Failed to attach background to card');
                        return;
                    }

                    const attachBody = await res2.json();

                    // Extract a usable background URL from the attach response.
                    // Be permissive: server might return a field named background_image_url, url, file_url, card_background_image_url, or nested card/background_image_url.
                    const newUrl =
                        attachBody.background_image_url ||
                        attachBody.url ||
                        attachBody.file_url ||
                        attachBody.upload_url ||
                        (attachBody.card && (attachBody.card.background_image_url || attachBody.card.image_url)) ||
                        (attachBody.data && (attachBody.data.background_image_url || attachBody.data.url)) ||
                        null;

                    // Update UI immediately using helper
                    applyBackgroundToUI(cardId, newUrl, _cardModalState.cardColor);

                } catch (err) {
                    console.error(err);
                    alert('Network error while uploading background');
                } finally {
                    fileInput.value = '';
                    uploadBtn.disabled = false;
                    deleteBgBtn.disabled = false;
                    uploadBtn.textContent = (_cardModalState.cardBackgroundUrl ? 'Change background image' : 'Upload background image');
                }
            });


            deleteBgBtn.addEventListener('click', async () => {
                if (!confirm('Remove card background image?')) return;
                deleteBgBtn.disabled = true;
                try {
                    const cardId = _cardModalState.cardId;
                    // Step 1: unlink in card table
                    const res = await fetch(`/api/cards/${cardId}/background_uploads`, { method: 'DELETE' });
                    if (!res.ok) {
                        const j = await res.json().catch(() => ({}));
                        alert(j.error || 'Failed to remove background');
                        deleteBgBtn.disabled = false;
                        return;
                    }
                    const j = await res.json();
                    const uploadId = j.upload_id || j.id || null;

                    // Step 2: delete actual upload via generic endpoint (frontend performs second request) if uploadId is present
                    if (uploadId) {
                        const res2 = await fetch(`/uploads/${uploadId}`, { method: 'DELETE' });
                        if (!res2.ok) {
                            console.warn('Failed to delete upload at /uploads/:', res2.status);
                        }
                    }

                    // Remove image from UI; restore color if present
                    applyBackgroundToUI(cardId, null, _cardModalState.cardColor);

                } catch (err) {
                    console.error(err);
                    alert('Network error while removing background');
                } finally {
                    deleteBgBtn.disabled = false;
                }
            });


            // append uploadContainer to modal just after color container
            const colorContainer = modalEl.querySelector('#card-modal-color');
            if (colorContainer && colorContainer.parentNode) {
                colorContainer.parentNode.insertBefore(uploadContainer, colorContainer.nextSibling);
            } else {
                modalEl.querySelector('.card-modal-left').insertBefore(uploadContainer, modalEl.querySelector('.card-modal-body'));
            }

            // expose a render function so refreshCardModal can call it after loading card data
            modalEl._renderCardBgState = renderCardBgState;
            renderCardBgState();
        }

        _cardModal = modal;
        return _cardModal;
    }

    // Initialize card-color swatch grid and handlers (called once)
    function initCardColorSwatches(modal) {
        const swGrid = modal.querySelector('#card-modal-color-swatches');
        if (!swGrid) return;

        const colors = [
            '#FF6B6B', '#FFAD69', '#FFD93D', '#6BCB77', '#4D96FF', '#845EC2', '#FF70A6', '#00C9A7', '#F9F871', null
        ];

        function render() {
            swGrid.innerHTML = '';
            const current = _cardModalState.cardColor || null;
            colors.forEach(col => {
                const sw = document.createElement('button');
                sw.className = 'swatch';
                sw.type = 'button';
                sw.tabIndex = 0;
                sw.setAttribute('data-color', col === null ? '' : col);
                sw.title = col || 'Default';
                if (col === null) {
                    sw.classList.add('swatch--default');
                    sw.textContent = 'Default';
                } else {
                    sw.style.backgroundColor = col;
                }
                if (current === col || (current === null && col === null)) sw.classList.add('selected');

                sw.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    onCardSwatchClick(col);
                });
                sw.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        sw.click();
                    }
                });

                swGrid.appendChild(sw);
            });
        }

        // call render initially (cardColor may be null until modal opened)
        render();

        // expose a way to refresh selection state after card data loads
        modal._refreshCardColorSwatches = render;
    }

    // Handler for clicking a swatch in the modal
    async function onCardSwatchClick(colorValue) {
        const cardId = _cardModalState.cardId;
        if (!cardId) {
            console.warn('No cardId set while changing card color');
            return;
        }
        const payloadColor = colorValue === null ? null : colorValue;
        try {
            const res = await apiPATCH(`/api/cards/color/${encodeURIComponent(cardId)}`, { color: payloadColor });
            if (!res.ok) {
                const j = await res.json().catch(() => ({}));
                alert(j.error || 'Failed to update card color');
                return;
            }

            // Update UI immediately: change left panel background (overrides var)
            const left = _cardModal.querySelector('.card-modal-left');
            if (payloadColor === null) {
                left.style.background = '';
            } else {
                left.style.background = payloadColor;
            }

            const cardEl = document.querySelector(`.card[data-card-id="${cardId}"]`);
            if (cardEl) {
                if (payloadColor === null) {
                    cardEl.style.background = '';
                } else {
                    cardEl.style.background = payloadColor;
                }
            }

            // store state and refresh swatch selection
            _cardModalState.cardColor = payloadColor;
            if (_cardModal && typeof _cardModal._refreshCardColorSwatches === 'function') _cardModal._refreshCardColorSwatches();

        } catch (err) {
            console.error(err);
            alert('Network error while updating card color');
        }
    }

    // Open modal for cardId
    async function openCardModal(cardId) {
        ensureCardModal();
        _cardModalState.cardId = cardId;

        // show modal
        _cardModal.style.display = 'block';

        // load card details & activity
        await refreshCardModal();

        // fetch current user id (if available) to gate edit/delete on comment items
        try {
            const ui = await apiGET('/user-info'); // expected to return { id, username, profile_picture, ...}
            _cardModalState.currentUserId = ui && ui.id ? ui.id : null;
        } catch (e) {
            _cardModalState.currentUserId = null;
        }
    }

    // Close modal
    function closeCardModal() {
        if (!_cardModal) return;
        _cardModal.style.display = 'none';
        _cardModalState.cardId = null;
    }

    async function refreshCardModal() {
        const cardId = _cardModalState.cardId;
        if (!cardId) return;

        // show placeholders while loading
        const titleEl = _cardModal.querySelector('#card-modal-title');
        const descEl = _cardModal.querySelector('#card-modal-desc');
        const activityListEl = _cardModal.querySelector('#card-activity-list');
        titleEl.value = 'Loading...';
        descEl.value = '';
        activityListEl.innerHTML = '<div style="opacity:0.6">Loading activity...</div>';

        try {
            // GET card data
            const card = await apiGET(`/api/cards/info/${cardId}`);
            titleEl.value = card.title || '';
            descEl.value = card.description || '';

            const left = _cardModal.querySelector('.card-modal-left');

            // inside refreshCardModal()
            _cardModalState.cardColor = (typeof card.color !== 'undefined') ? (card.color || null) : null;

            // Always update modal state with server value so the modal reflects latest server-side background.
            _cardModalState.cardBackgroundUrl = card.background_image_url || null;

            if (_cardModalState.cardBackgroundUrl) {
                left.style.background = `url('${_cardModalState.cardBackgroundUrl}') center/cover no-repeat`;
            } else if (_cardModalState.cardColor) {
                left.style.background = _cardModalState.cardColor;
            } else {
                left.style.background = '';
            }

            // Refresh upload UI (thumbnail + buttons)
            if (_cardModal && typeof _cardModal._renderCardBgState === 'function') {
                _cardModal._renderCardBgState();
            }


            // Also update board card element if present so board view matches modal
            const cardEl = document.querySelector(`.card[data-card-id="${cardId}"]`);
            if (cardEl) {
                if (_cardModalState.cardBackgroundUrl) {
                    cardEl.style.background = `url('${_cardModalState.cardBackgroundUrl}') center/cover no-repeat`;
                } else if (_cardModalState.cardColor) {
                    cardEl.style.background = _cardModalState.cardColor;
                } else {
                    cardEl.style.background = '';
                }
            }

            // refresh swatch selection
            if (_cardModal && typeof _cardModal._refreshCardColorSwatches === 'function') _cardModal._refreshCardColorSwatches();

            titleEl.focus();

            // GET activity
            let activity = [];
            try {
                activity = await apiGET(`/api/cards/${cardId}/activity`);
            } catch (e) {
                activity = [];
            }

            renderActivityList(activityListEl, activity, currentUserId = sessionStorage.getItem('current_user_id'));
        } catch (err) {
            console.error('Failed to load card modal data', err);
            activityListEl.innerHTML = '<div style="opacity:0.6">Failed to load activity</div>';
        }
    }

    // Render activity list; activity is an array of { id, card_id, user_id, username, type, action, content, created_at, editable }
    function renderActivityList(container, items, currentUserId = sessionStorage.getItem('current_user_id')) {
        container.innerHTML = '';
        if (!items || items.length === 0) {
            container.innerHTML = '<div style="opacity:0.6">No activity yet</div>';
            return;
        }
        // show newest first (assume server returns sorted but ensure it)
        items.sort((a,b) => new Date(b.created_at) - new Date(a.created_at));

        for (const it of items) {
            const el = document.createElement('div');
            el.className = 'activity-item';
            el.dataset.activityId = it.id;

            const meta = document.createElement('div');
            meta.className = 'meta';
            const when = new Date(it.created_at).toLocaleString();
            const who = it.username ? escapeHtml(it.username) : ('User ' + (it.user_id || ''));
            meta.innerHTML = `<span class="who">${who}</span> â€¢ <span class="when">${when}</span>`;

            const content = document.createElement('div');
            content.className = 'content';
            // If it's a comment, allow edit/delete for items the current user owns
            if (it.type === 'comment') {
                content.innerHTML = escapeHtml(it.content || '');
            } else { // history / activity
                content.innerHTML = escapeHtml(it.content || it.action || '(activity)');
            }

            el.appendChild(meta);
            el.appendChild(content);

            // first make sure both it.user_id and currentUserId are strings for comparison
            const uidStr = it.user_id ? String(it.user_id) : null;

            // controls for comment items that belong to current user
            if (it.type === 'comment' && uidStr === currentUserId) {
                const controls = document.createElement('div');
                controls.className = 'activity-controls';
                const btnEdit = document.createElement('button');
                btnEdit.className = 'btn ghost small';
                btnEdit.textContent = 'Edit';
                const btnDel = document.createElement('button');
                btnDel.className = 'btn ghost small';
                btnDel.textContent = 'Delete';
                controls.appendChild(btnEdit);
                controls.appendChild(btnDel);

                btnEdit.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    startEditComment(el, it);
                });
                btnDel.addEventListener('click', async (ev) => {
                    ev.stopPropagation();
                    if (!confirm('Delete this comment?')) return;
                    try {
                        const res = await apiDELETE(`/api/card/comment/${encodeURIComponent(it.id)}`);
                        if (res.ok) {
                            // Remove from DOM and optionally refresh
                            el.remove();
                        } else {
                            const j = await res.json();
                            alert(j.error || 'Failed to delete comment');
                        }
                    } catch (err) {
                        console.error(err);
                        alert('Network error while deleting comment');
                    }
                });
                el.appendChild(controls);
            }

            container.appendChild(el);
        }
    }

    // Start inline editing of a comment item inside activity list
    function startEditComment(activityEl, activityObj) {
        // activityEl contains .content element
        const contentEl = activityEl.querySelector('.content');
        const orig = activityObj.content || '';
        // replace content with textarea + save/cancel
        contentEl.innerHTML = '';
        const ta = document.createElement('textarea');
        ta.value = orig;
        ta.style.width = '96%';
        ta.style.minHeight = '64px';
        ta.style.padding = '8px';
        ta.style.borderRadius = '6px';
        ta.style.border = '1px solid #333';
        ta.style.background = 'var(--btn-color)';
        ta.style.color = '#e0e0e0';

        const actions = document.createElement('div');
        actions.style.display = 'flex';
        actions.style.justifyContent = 'flex-end';
        actions.style.gap = '8px';
        actions.style.marginTop = '8px';
        const btnCancel = document.createElement('button');
        btnCancel.className = 'btn ghost';
        btnCancel.textContent = 'Cancel';
        const btnSave = document.createElement('button');
        btnSave.className = 'btn';
        btnSave.textContent = 'Save';

        actions.appendChild(btnCancel);
        actions.appendChild(btnSave);

        contentEl.appendChild(ta);
        contentEl.appendChild(actions);
        ta.focus();

        btnCancel.addEventListener('click', () => {
            // restore original content text
            contentEl.textContent = orig;
        });

        btnSave.addEventListener('click', async () => {
            const newContent = ta.value.trim();
            if (!newContent) {
                alert('Comment cannot be empty');
                ta.focus();
                return;
            }
            btnSave.disabled = true;
            try {
                const res = await apiPATCH(`/api/card/comment/${encodeURIComponent(activityObj.id)}`, { content: newContent });
                if (res.ok) {
                    // update UI
                    contentEl.textContent = newContent;
                } else {
                    const j = await res.json();
                    alert(j.error || 'Failed to update comment');
                    contentEl.textContent = orig;
                }
            } catch (err) {
                console.error(err);
                alert('Network error while updating comment');
                contentEl.textContent = orig;
            } finally {
                btnSave.disabled = false;
            }
        });
    }

    // Add comment handler (from new comment box)
    async function addCommentFromModal() {
        const cardId = _cardModalState.cardId;
        if (!cardId) return;
        const ta = _cardModal.querySelector('#card-new-comment');
        const content = ta.value.trim();
        if (!content) return;
        const addBtn = _cardModal.querySelector('#card-add-comment');
        addBtn.disabled = true;
        try {
            const res = await apiPOST(`/api/card/${encodeURIComponent(cardId)}/comment`, { content });
            if (!res.ok) {
                const j = await res.json();
                alert(j.error || 'Failed to add comment');
                return;
            }
            // Success: backend should return created comment object (including id, user_id, username, created_at)
            const newComment = await res.json();
            // Prepend to activity list so newest shows on top
            const activityListEl = _cardModal.querySelector('#card-activity-list');
            renderActivityList(activityListEl, [newComment].concat(Array.from(activityListEl.children).map(node => {
                // we don't have the full object for existing DOM nodes; do a full refresh instead
                return null;
            }).filter(Boolean)), sessionStorage.getItem('current_user_id'));
            // Simpler: refresh entire activity list
            await refreshCardModal();
            ta.value = '';
        } catch (err) {
            console.error(err);
            alert('Network error while adding comment');
        } finally {
            addBtn.disabled = false;
        }
    }

    // Save card (title + description)
    async function saveCardModal() {
        const cardId = _cardModalState.cardId;
        if (!cardId) return;
        const titleEl = _cardModal.querySelector('#card-modal-title');
        const descEl = _cardModal.querySelector('#card-modal-desc');
        const title = titleEl.value.trim();
        const description = descEl.value.trim();

        if (!title) {
            alert('Title cannot be empty');
            titleEl.focus();
            return;
        }
        const btn = _cardModal.querySelector('#card-modal-save');
        btn.disabled = true;
        btn.textContent = 'Saving...';
        try {
            const res = await apiPATCH(`/api/cards/${encodeURIComponent(cardId)}`, { title, description });
            if (!res.ok) {
                const j = await res.json();
                alert(j.error || 'Failed to save card');
                return;
            }
            // update any card DOM elements on the page (title text)
            const cardEl = document.querySelector(`.card[data-card-id="${cardId}"]`);
            if (cardEl) {
                const titleNode = cardEl.querySelector('.card-title-text');
                if (titleNode) titleNode.textContent = title;
                const descNode = cardEl.querySelector('.card-desc-text');
                if (descNode) descNode.textContent = description;
            }
            closeCardModal();
        } catch (err) {
            console.error(err);
            alert('Network error while saving card');
        } finally {
            btn.disabled = false;
            btn.textContent = 'Save';
        }
    }

    // Expose functions globally so other code can call them
    window.openCardModal = openCardModal;
    window.closeCardModal = closeCardModal;
    window.refreshCardModal = refreshCardModal;

    // Update attachCardActionHandlers to open modal instead of inline edit
    // Replace your existing attachCardActionHandlers implementation with this one:
    window.attachCardActionHandlers = function (cardEl) {
        const cardId = parseInt(cardEl.dataset.cardId, 10);
        const editBtn = cardEl.querySelector('.edit-card');
        const delBtn = cardEl.querySelector('.delete-card');

        // avoid adding duplicate handlers
        if (!editBtn._hasHandler) {
            editBtn.addEventListener('click', (ev) => {
                ev.stopPropagation();
                // open modal
                openCardModal(cardId);
            });
            editBtn._hasHandler = true;
        }
        if (!delBtn._hasHandler) {
            delBtn.addEventListener('click', async (ev) => {
                ev.stopPropagation();
                if (!confirm('Delete card?')) return;
                const res = await apiDELETE(`/api/cards/${cardId}`);
                if (res.ok) {
                    // remove card from DOM
                    cardEl.parentElement && cardEl.parentElement.removeChild(cardEl);
                } else {
                    const j = await res.json();
                    alert(j.error || 'Failed to delete card');
                }
            });
            delBtn._hasHandler = true;
        }

        // double-click to open modal
        if (!cardEl._dblHandler) {
            cardEl.addEventListener('dblclick', (ev) => {
                if (ev.target.closest('.edit-card') || ev.target.closest('.delete-card') || ev.target.closest('.card-complete')) return;
                openCardModal(cardId);
            });
            cardEl._dblHandler = true;
        }

        // ensure completion handler still attached
        attachCardCompleteHandler(cardEl);
    };

})();

/* Utility */
function escapeHtml(s) {
    return String(s || '').replace(/[&<>"']/g, (m) => ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;" })[m]);
}
function escapeAttr(s) {
    return String(s || '').replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

/* cancel modal overlay bindings for old modal (kept in DOM but not used heavily) */
document.getElementById('modal-cancel').addEventListener('click', () => {
    document.getElementById('modal-overlay').style.display = 'none';
});
document.getElementById('modal-overlay').addEventListener('click', (e) => {
    if (e.target === document.getElementById('modal-overlay')) document.getElementById('modal-overlay').style.display = 'none';
});

/* pending-invite cancel helper used by dynamically inserted buttons */
async function cancelInvite(id) {
    if (!confirm('Cancel this invite?')) return;
    try {
        const res = await apiDELETE(`/invites/${id}`);
        if (res.ok) await refreshModalData();
        else {
            const j = await res.json();
            alert(j.error || 'Failed to cancel invite');
        }
    } catch (err) {
        console.error(err);
    }
}

// Board actions menu generator (replaces #actions-menu-board if present).
// - Uses original buttons: #rename-board-btn and #delete-board-btn (class "menu-item").
// - Removes duplicate/toggle/labels controls.
// - Color swatch uses apiPATCH('/api/boards/color/<id>', { color }) similar to list menu sample.
// - Rename/Delete logic moved inside the IIFE (uses existing inlineRenameBoard + apiDELETE + loaders).
function initBoardActionsMenu() {
    let openMenu = null;
    let openMenuCleanup = null;
    const existing = document.getElementById('actions-menu-board');
    if (existing) existing.remove();

    // CSS injected so menu is self-contained
    const style = document.createElement('style');
    style.textContent = `
    #actions-menu-board.generated {
        position: absolute;
        min-width: 240px;
        max-width: 360px;
        background: var(--ctr-color, #1f1f1f);
        color: var(--text-color, #e8e8e8);
        border-radius: 8px;
        box-shadow: 0 8px 28px rgba(0,0,0,0.35);
        padding: 0;
        z-index: 20000;
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    #actions-menu-board .bm-header {
        padding: 10px 12px;
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:8px;
        border-top-left-radius:8px;
        border-top-right-radius:8px;
        background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    }
    #actions-menu-board .bm-header-title { font-weight:600; font-size:14px; }
    #actions-menu-board .bm-sub { font-size:12px; opacity:0.8; }
    #actions-menu-board .bm-close { all: unset; cursor:pointer; padding:6px; border-radius:6px; }
    #actions-menu-board .bm-divider { height:1px; background:var(--hdr-color, rgba(255,255,255,0.06)); margin:6px 0; }
    #actions-menu-board .bm-section { padding:10px 12px; }
    #actions-menu-board .menu-item {
        all: unset;
        display:block;
        width:100%;
        padding:8px 10px;
        font-size:14px;
        cursor:pointer;
        border-radius:6px;
        text-align:left;
    }
    #actions-menu-board .menu-item:focus, #actions-menu-board .menu-item:hover { background: rgba(255,255,255,0.02); outline:none; }
    #actions-menu-board .menu-item--danger { color:#ff6b6b; font-weight:600; }
    #actions-menu-board .swatch-grid { display:flex; flex-wrap:wrap; gap:8px; margin-top:6px; }
    #actions-menu-board .swatch { width:34px; height:34px; border-radius:8px; cursor:pointer; border:2px solid transparent; box-sizing:border-box; }
    #actions-menu-board .swatch:focus, #actions-menu-board .swatch:hover { transform: translateY(-2px); border-color: rgba(255,255,255,0.12); outline:none; }
    #actions-menu-board .swatch--default { display:flex; align-items:center; justify-content:center; background: repeating-linear-gradient(45deg, #2b2b2b 0 6px, #262626 6px 12px); color: rgba(255,255,255,0.5); font-size:11px; }
    `;
    document.head.appendChild(style);

    // Build the menu root
    const menu = document.createElement('div');
    menu.id = 'actions-menu-board';
    menu.className = 'generated';
    menu.setAttribute('role', 'menu');
    menu.tabIndex = -1;

    // Header (title + close)
    const header = document.createElement('div');
    header.className = 'bm-header';
    const headLeft = document.createElement('div');
    const title = document.createElement('div');
    title.className = 'bm-header-title';
    title.textContent = 'Board actions';
    const sub = document.createElement('div');
    sub.className = 'bm-sub';
    sub.textContent = 'Manage this board';
    headLeft.appendChild(title);
    headLeft.appendChild(sub);
    const closeBtn = document.createElement('button');
    closeBtn.className = 'bm-close';
    closeBtn.type = 'button';
    closeBtn.setAttribute('aria-label', 'Close menu');
    closeBtn.innerHTML = '&#10005;';
    closeBtn.addEventListener('click', (e) => { e.stopPropagation(); closeMenu(); });
    header.appendChild(headLeft);
    header.appendChild(closeBtn);
    menu.appendChild(header);

    // divider
    menu.appendChild(Object.assign(document.createElement('div'), { className: 'bm-divider' }));

    // Color section (swatches) - will call apiPATCH('/api/boards/color/<id>', { color })
    const colorSection = document.createElement('div');
    colorSection.className = 'bm-section';
    const colorLabel = document.createElement('div');
    colorLabel.textContent = 'Board color';
    colorLabel.style.fontSize = '13px';
    colorLabel.style.marginBottom = '6px';
    colorSection.appendChild(colorLabel);

    const swGrid = document.createElement('div');
    swGrid.className = 'swatch-grid';

    const colors = [
        '#FF6B6B', '#FFAD69', '#FFD93D', '#6BCB77', '#4D96FF', '#845EC2', '#FF70A6', '#00C9A7', '#F9F871', null
    ];

    // helper: resolve board id from anchor or UI
    function resolveBoardId() {
        try {
            if (typeof currentBoardId !== 'undefined' && currentBoardId) return currentBoardId;
        } catch (e) { /* ignore */ }
        return null;
    }

    // swatch click handler - uses apiPATCH exactly as you required
    async function onSwatchClick(colorValue, anchor) {
        const boardId = resolveBoardId();
        if (!boardId) {
            console.warn('No boardId found for color change');
            return;
        }
        const payloadColor = colorValue === null ? null : colorValue;
        try {
            // apiPATCH must exist in your environment (same as your list menu example)
            const res = await apiPATCH(`/api/boards/color/${boardId}`, { color: payloadColor });
            if (!res.ok) {
                const j = await res.json().catch(() => ({}));
                alert(j.error || 'Failed to update board color');
                return;
            }
            // Apply instantly if possible (try a few common hooks)
            const boardEl = document.getElementById('lists-wrap');
            if (payloadColor === null) {
                await loadLists(boardId); // reload to reset
            } else {
                boardEl.style.background = payloadColor;
            }
            closeMenu();
        } catch (err) {
            console.error(err);
            alert('Network error while updating color');
        }
    }

    // create swatches
    colors.forEach(col => {
        const sw = document.createElement('button');
        sw.className = 'swatch';
        sw.type = 'button';
        sw.tabIndex = 0;
        sw.setAttribute('data-color', col === null ? '' : col);
        sw.title = col || 'Default';
        if (col === null) {
            sw.classList.add('swatch--default');
            sw.textContent = 'Default';
        } else {
            sw.style.backgroundColor = col;
        }
        sw.addEventListener('click', (ev) => {
            ev.stopPropagation();
            onSwatchClick(col, currentAnchor);
        });
        sw.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                sw.click();
            }
        });
        swGrid.appendChild(sw);
    });

    colorSection.appendChild(swGrid);
    menu.appendChild(colorSection);

    // divider
    menu.appendChild(Object.assign(document.createElement('div'), { className: 'bm-divider' }));

    // --- Upload background controls (board-level) ---
    const uploadContainer = document.createElement('div');
    uploadContainer.classList.add('bm-section');
    uploadContainer.style.marginTop = '12px';

    // Visual label
    const uploadLabel = document.createElement('div');
    uploadLabel.className = 'options-menu-color-label';
    uploadLabel.textContent = 'Board background image';
    uploadLabel.style.fontSize = '13px';
    uploadLabel.style.opacity = '0.95';
    uploadContainer.appendChild(uploadLabel);

    // file input (hidden) + visible button to trigger it
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';
    fileInput.style.display = 'none';

    const uploadBtn = document.createElement('button');
    uploadBtn.type = 'button';
    uploadBtn.className = 'options-menu-item options-menu-more';
    uploadBtn.textContent = (globalBoardBackgroundUrl ? 'Change background image' : 'Upload background image');
    uploadBtn.addEventListener('click', () => fileInput.click());

    boardId = resolveBoardId();
    if (!boardId) {
        alert('Cannot determine board ID for upload');
        uploadBtn.disabled = false;
        uploadBtn.textContent = (globalBoardBackgroundUrl ? 'Change background image' : 'Upload background image');
        fileInput.value = '';
        return;
    }

    fileInput.addEventListener('change', async (ev) => {
        if (!fileInput.files || fileInput.files.length === 0) return;
        const f = fileInput.files[0];
        uploadBtn.disabled = true;
        deleteBgBtn.disabled = true;
        uploadBtn.textContent = 'Uploadingâ€¦';

        boardArea = document.getElementById('lists-wrap');

        try {
            // Step 1: POST to generic /uploads (multipart)
            const form = new FormData();
            form.append('file', f);
            const res1 = await fetch('/uploads', {
                method: 'POST',
                body: form
            });

            if (!res1.ok) {
                const err = await res1.json().catch(() => ({}));
                alert(err.error || 'Upload failed');
                return;
            }
            const body = await res1.json();
            const uploadId = body.upload_id;
            if (!uploadId) {
                alert('Upload returned unexpected response');
                return;
            }

            // Step 2: attach that upload to the board
            const res2 = await fetch(`/api/boards/${boardId}/background_uploads`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ upload_id: uploadId })
            });

            if (!res2.ok) {
                const err = await res2.json().catch(() => ({}));
                alert(err.error || 'Failed to attach background to board');
                return;
            }

            const attachBody = await res2.json();
            globalBoardBackgroundUrl = attachBody.url || null;

            // apply image immediately (image overrides color)
            if (boardArea && globalBoardBackgroundUrl) {
                boardArea.style.background = `url('${globalBoardBackgroundUrl}') center/cover no-repeat`;
            }

            // update menu button label
            uploadBtn.textContent = 'Change background image';
            // optionally show thumbnail / change delete button state below (we will create those next)
            renderBgControlsState();

        } catch (err) {
            console.error(err);
            alert('Network error while uploading background');
        } finally {
            fileInput.value = '';
            uploadBtn.disabled = false;
            deleteBgBtn.disabled = false;
        }
    });

    // create a small thumbnail + delete button area (will be populated if an image exists)
    const bgControls = document.createElement('div');
    bgControls.style.display = 'flex';
    bgControls.style.alignItems = 'center';
    bgControls.style.gap = '8px';
    bgControls.style.marginTop = '4px';

    const thumb = document.createElement('img');
    thumb.style.width = '64px';
    thumb.style.height = '40px';
    thumb.style.objectFit = 'cover';
    thumb.style.borderRadius = '6px';
    thumb.style.display = 'none'; // shown when image exists

    const deleteBgBtn = document.createElement('button');
    deleteBgBtn.type = 'button';
    deleteBgBtn.className = 'options-menu-item options-menu-item--danger';
    deleteBgBtn.textContent = 'Remove background';
    deleteBgBtn.style.display = 'none';

    // handler for delete: two requests (unlink, then frontend deletes upload)
    deleteBgBtn.addEventListener('click', async () => {
        if (!confirm('Remove board background image?')) return;
        deleteBgBtn.disabled = true;
        try {
            // Step 1: unlink in board table
            const res = await fetch(`/api/boards/${boardId}/background_uploads`, { method: 'DELETE' });
            if (!res.ok) {
                const j = await res.json().catch(() => ({}));
                alert(j.error || 'Failed to remove background');
                deleteBgBtn.disabled = false;
                return;
            }
            const j = await res.json();
            const uploadId = j.upload_id;

            // Step 2: delete actual upload via generic endpoint (frontend performs second request)
            if (uploadId) {
                const res2 = await fetch(`/uploads/${uploadId}`, { method: 'DELETE' });
                if (!res2.ok) {
                    // not fatal â€” log and continue, but notify
                    console.warn('Failed to delete upload at /uploads/:', res2.status);
                }
            }

            // remove image from UI; restore color if present
            globalBoardBackgroundUrl = null;
            await loadLists(boardId);
            renderBgControlsState();
            deleteBgBtn.disabled = false;

        } catch (err) {
            console.error(err);
            alert('Network error while removing background');
            deleteBgBtn.disabled = false;
        }
    });

    // helper: update thumbnail + visibility based on current state
    function renderBgControlsState() {
        if (globalBoardBackgroundUrl) {
            thumb.src = globalBoardBackgroundUrl;
            thumb.style.display = 'block';
            deleteBgBtn.style.display = 'inline-block';
            uploadBtn.textContent = 'Change background image';
        } else {
            thumb.style.display = 'none';
            deleteBgBtn.style.display = 'none';
            uploadBtn.textContent = 'Upload background image';
        }
    }

    uploadContainer.appendChild(fileInput);
    uploadContainer.appendChild(uploadBtn);
    uploadContainer.appendChild(bgControls);
    bgControls.appendChild(thumb);
    bgControls.appendChild(deleteBgBtn);

    // initialize view
    renderBgControlsState();

    // append uploadContainer to menu just after color container
    menu.appendChild(uploadContainer);


    // divider
    menu.appendChild(Object.assign(document.createElement('div'), { className: 'bm-divider' }));

    // Actions section: use original Rename/Delete buttons (IDs + class menu-item)
    const actionSection = document.createElement('div');
    actionSection.className = 'bm-section';

    const renameBtn = document.createElement('button');
    renameBtn.id = 'rename-board-btn';
    renameBtn.className = 'menu-item';
    renameBtn.type = 'button';
    renameBtn.textContent = 'Rename';

    // Move original rename logic here: use boardsCache, currentBoardId, inlineRenameBoard
    renameBtn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        // original logic: find board in boardsCache and call inlineRenameBoard(b.id, b.title);
        try {
            const b = (typeof boardsCache !== 'undefined' && Array.isArray(boardsCache)) ? boardsCache.find(x => x.id === currentBoardId) : null;
            if (!b) return;
            if (typeof inlineRenameBoard === 'function') {
                inlineRenameBoard(b.id, b.title);
            } else {
                // fallback: dispatch event
                document.dispatchEvent(new CustomEvent('board:rename', { detail: { boardId: b.id, title: b.title } }));
            }
        } catch (err) {
            console.error(err);
        } finally {
            closeMenu();
        }
    });

    const deleteBtn = document.createElement('button');
    deleteBtn.id = 'delete-board-btn';
    deleteBtn.className = 'menu-item menu-item--danger';
    deleteBtn.type = 'button';
    deleteBtn.textContent = 'Delete';

    // Move original delete logic here (async)
    deleteBtn.addEventListener('click', async (ev) => {
        ev.stopPropagation();
        try {
            if (!currentBoardId) return;
            if (!confirm('Delete board and everything inside?')) return;
            const res = await apiDELETE(`/api/boards/${currentBoardId}`);
            if (res.ok) {
                // follow original behavior
                currentBoardId = null;
                const bt = document.getElementById('board-title');
                if (bt) bt.textContent = 'Select a board';
                const listsWrap = document.getElementById('lists-wrap');
                if (listsWrap) listsWrap.innerHTML = '';
                // update URL and show start page
                location.hash = '';
                if (typeof loadStartPageBoards === 'function') await loadStartPageBoards();
                if (typeof showStartPage === 'function') showStartPage();
                if (typeof loadBoards === 'function') await loadBoards();
                closeMenu();
            } else {
                const j = await res.json().catch(() => ({}));
                alert(j.error || 'Failed');
            }
        } catch (err) {
            console.error(err);
            alert('Network error while deleting board');
        }
    });

    // Close button (action) to match original menu behaviour
    const closeAction = document.createElement('button');
    closeAction.className = 'menu-item';
    closeAction.type = 'button';
    closeAction.textContent = 'Close';
    closeAction.addEventListener('click', (ev) => { ev.stopPropagation(); closeMenu(); });

    actionSection.appendChild(renameBtn);
    actionSection.appendChild(deleteBtn);
    actionSection.appendChild(Object.assign(document.createElement('div'), { className: 'bm-divider' }));
    actionSection.appendChild(closeAction);

    menu.appendChild(actionSection);

    // Inserted into DOM on open only
    let currentAnchor = null;

    function positionMenuNear(menuEl, anchorBtn) {
        const rect = anchorBtn.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        if (!document.body.contains(menuEl)) document.body.appendChild(menuEl);
        const menuRect = menuEl.getBoundingClientRect();
        const menuWidth = Math.max(menuRect.width || 260, 240);
        const menuHeight = menuRect.height || 220;

        let left = rect.right - menuWidth + window.scrollX;
        let top = rect.bottom + 8 + window.scrollY;

        if (left < 8 + window.scrollX) left = Math.max(8 + window.scrollX, rect.left + window.scrollX);
        if (top + menuHeight > window.scrollY + viewportHeight - 8) {
            top = rect.top + window.scrollY - menuHeight - 8;
        }
        if (top < 8 + window.scrollY) top = 8 + window.scrollY;

        menuEl.style.left = Math.round(left) + 'px';
        menuEl.style.top = Math.round(top) + 'px';
    }

    function openAt(anchorBtn) {
        if (openMenu) closeMenu();
        currentAnchor = anchorBtn;
        document.body.appendChild(menu);
        positionMenuNear(menu, anchorBtn);
        menu.focus();

        function onDocClick(e) {
            if (!menu.contains(e.target) && e.target !== anchorBtn) closeMenu();
        }
        function onKeyDown(e) {
            if (e.key === 'Escape') closeMenu();
            if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                e.preventDefault();
                focusNext(menu, e.key === 'ArrowDown' ? 1 : -1);
            }
        }
        function onScrollResize() {
            if (!currentAnchor) return;
            positionMenuNear(menu, currentAnchor);
        }

        document.addEventListener('click', onDocClick);
        document.addEventListener('keydown', onKeyDown);
        window.addEventListener('resize', onScrollResize);
        window.addEventListener('scroll', onScrollResize, true);

        openMenu = menu;
        openMenuCleanup = () => {
            document.removeEventListener('click', onDocClick);
            document.removeEventListener('keydown', onKeyDown);
            window.removeEventListener('resize', onScrollResize);
            window.removeEventListener('scroll', onScrollResize, true);
        };
    }

    function closeMenu() {
        if (!openMenu) return;
        try { openMenuCleanup && openMenuCleanup(); } catch (e) { /* ignore */ }
        try { openMenu.remove(); } catch (e) { /* ignore */ }
        openMenu = null;
        openMenuCleanup = null;
        currentAnchor = null;
    }

    function focusNext(root, dir = 1) {
        const items = Array.from(root.querySelectorAll('button, [tabindex]:not([tabindex="-1"])'))
            .filter(el => !el.disabled && el.getAttribute('aria-hidden') !== 'true');
        if (!items.length) return;
        const idx = items.indexOf(document.activeElement);
        const next = (idx + dir + items.length) % items.length;
        items[next].focus();
    }

    // Wire trigger
    const trigger = document.getElementById('actions-menu-btn');
    if (trigger) {
        trigger.addEventListener('click', (ev) => {
            ev.stopPropagation();
            if (openMenu && currentAnchor === trigger) {
                closeMenu();
            } else {
                openAt(trigger);
            }
        });
    } else {
        console.warn('actions-menu-btn not found - create an element with id="actions-menu-btn" to open the board menu.');
    }

    // expose a programmatic API
    window.openBoardActionsMenuAt = (el) => {
        if (!el) throw new Error('anchor element required');
        openAt(el);
    };
    window.closeBoardActionsMenu = closeMenu;
    window.updateBoardMenuUi = renderBgControlsState
}


</script>
</body>
</html>
